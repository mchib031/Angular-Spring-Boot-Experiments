(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/fire'), require('rxjs'), require('rxjs/operators'), require('@angular/core'), require('@angular/fire/auth'), require('@angular/fire/app'), require('firebase/app'), require('rxfire/firestore'), require('firebase/firestore')) :
    typeof define === 'function' && define.amd ? define('@angular/fire/firestore', ['exports', '@angular/fire', 'rxjs', 'rxjs/operators', '@angular/core', '@angular/fire/auth', '@angular/fire/app', 'firebase/app', 'rxfire/firestore', 'firebase/firestore'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.angular = global.angular || {}, global.angular.fire = global.angular.fire || {}, global.angular.fire.firestore = {}), global.angular.fire, global.rxjs, global.rxjs.operators, global.ng.core, global.angular.fire.auth, global.angular.fire.app, global.app$1, global['rxfire-firestore'], global['firebase-firestore']));
}(this, (function (exports, fire, rxjs, operators, i0, auth, app, app$1, firestore$1, firestore) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    var Firestore = /** @class */ (function () {
        function Firestore(firestore) {
            return firestore;
        }
        return Firestore;
    }());
    var FIRESTORE_PROVIDER_NAME = 'firestore';
    var FirestoreInstances = /** @class */ (function () {
        function FirestoreInstances() {
            return fire.ɵgetAllInstancesOf(FIRESTORE_PROVIDER_NAME);
        }
        return FirestoreInstances;
    }());
    var firestoreInstance$ = rxjs.timer(0, 300).pipe(operators.concatMap(function () { return rxjs.from(fire.ɵgetAllInstancesOf(FIRESTORE_PROVIDER_NAME)); }), operators.distinct());

    var PROVIDED_FIRESTORE_INSTANCES = new i0.InjectionToken('angularfire2.firestore-instances');
    function defaultFirestoreInstanceFactory(provided, defaultApp) {
        var defaultFirestore = fire.ɵgetDefaultInstanceOf(FIRESTORE_PROVIDER_NAME, provided, defaultApp);
        // TODO how do I throw if it's undefined, unless @Optional(), is there an Angular NULL_INJECTOR token
        // or something, can I use an @NgModule providers or something?
        return new Firestore(defaultFirestore);
    }
    function firestoreInstanceFactory(fn) {
        return function (zone) {
            var firestore = fire.ɵmemoizeInstance(fn, zone);
            return new Firestore(firestore);
        };
    }
    var FIRESTORE_INSTANCES_PROVIDER = {
        provide: FirestoreInstances,
        deps: [
            [new i0.Optional(), PROVIDED_FIRESTORE_INSTANCES],
        ]
    };
    var DEFAULT_FIRESTORE_INSTANCE_PROVIDER = {
        provide: Firestore,
        useFactory: defaultFirestoreInstanceFactory,
        deps: [
            [new i0.Optional(), PROVIDED_FIRESTORE_INSTANCES],
            app.FirebaseApp,
        ]
    };
    var FirestoreModule = /** @class */ (function () {
        function FirestoreModule() {
            app$1.registerVersion('angularfire', fire.VERSION.full, 'fst');
        }
        return FirestoreModule;
    }());
    FirestoreModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0__namespace, type: FirestoreModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FirestoreModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0__namespace, type: FirestoreModule });
    FirestoreModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0__namespace, type: FirestoreModule, providers: [
            DEFAULT_FIRESTORE_INSTANCE_PROVIDER,
            FIRESTORE_INSTANCES_PROVIDER,
        ] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0__namespace, type: FirestoreModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        providers: [
                            DEFAULT_FIRESTORE_INSTANCE_PROVIDER,
                            FIRESTORE_INSTANCES_PROVIDER,
                        ]
                    }]
            }], ctorParameters: function () { return []; } });
    function provideFirestore(fn) {
        return {
            ngModule: FirestoreModule,
            providers: [{
                    provide: PROVIDED_FIRESTORE_INSTANCES,
                    useFactory: firestoreInstanceFactory(fn),
                    multi: true,
                    deps: [
                        i0.NgZone,
                        fire.ɵAngularFireSchedulers,
                        app.FirebaseApps,
                        // Firestore+Auth work better if Auth is loaded first
                        [new i0.Optional(), auth.AuthInstances],
                    ]
                }]
        };
    }

    // DO NOT MODIFY, this file is autogenerated by tools/build.ts
    var collectionChanges = fire.ɵzoneWrap(firestore$1.collectionChanges, true);
    var collectionSnapshots = fire.ɵzoneWrap(firestore$1.collection, true);
    var sortedChanges = fire.ɵzoneWrap(firestore$1.sortedChanges, true);
    var auditTrail = fire.ɵzoneWrap(firestore$1.auditTrail, true);
    var collectionData = fire.ɵzoneWrap(firestore$1.collectionData, true);
    var docSnapshots = fire.ɵzoneWrap(firestore$1.doc, true);
    var docData = fire.ɵzoneWrap(firestore$1.docData, true);
    var snapToData = fire.ɵzoneWrap(firestore$1.snapToData, true);
    var fromRef = fire.ɵzoneWrap(firestore$1.fromRef, true);

    // DO NOT MODIFY, this file is autogenerated by tools/build.ts
    var addDoc = fire.ɵzoneWrap(firestore.addDoc, true);
    var arrayRemove = fire.ɵzoneWrap(firestore.arrayRemove, true);
    var arrayUnion = fire.ɵzoneWrap(firestore.arrayUnion, true);
    var clearIndexedDbPersistence = fire.ɵzoneWrap(firestore.clearIndexedDbPersistence, true);
    var collection = fire.ɵzoneWrap(firestore.collection, true);
    var collectionGroup = fire.ɵzoneWrap(firestore.collectionGroup, true);
    var connectFirestoreEmulator = fire.ɵzoneWrap(firestore.connectFirestoreEmulator, true);
    var deleteDoc = fire.ɵzoneWrap(firestore.deleteDoc, true);
    var deleteField = fire.ɵzoneWrap(firestore.deleteField, true);
    var disableNetwork = fire.ɵzoneWrap(firestore.disableNetwork, true);
    var doc = fire.ɵzoneWrap(firestore.doc, true);
    var documentId = fire.ɵzoneWrap(firestore.documentId, true);
    var enableIndexedDbPersistence = fire.ɵzoneWrap(firestore.enableIndexedDbPersistence, true);
    var enableMultiTabIndexedDbPersistence = fire.ɵzoneWrap(firestore.enableMultiTabIndexedDbPersistence, true);
    var enableNetwork = fire.ɵzoneWrap(firestore.enableNetwork, true);
    var endAt = fire.ɵzoneWrap(firestore.endAt, true);
    var endBefore = fire.ɵzoneWrap(firestore.endBefore, true);
    var getDoc = fire.ɵzoneWrap(firestore.getDoc, true);
    var getDocFromCache = fire.ɵzoneWrap(firestore.getDocFromCache, true);
    var getDocFromServer = fire.ɵzoneWrap(firestore.getDocFromServer, true);
    var getDocs = fire.ɵzoneWrap(firestore.getDocs, true);
    var getDocsFromCache = fire.ɵzoneWrap(firestore.getDocsFromCache, true);
    var getDocsFromServer = fire.ɵzoneWrap(firestore.getDocsFromServer, true);
    var getFirestore = fire.ɵzoneWrap(firestore.getFirestore, true);
    var increment = fire.ɵzoneWrap(firestore.increment, true);
    var initializeFirestore = fire.ɵzoneWrap(firestore.initializeFirestore, true);
    var limit = fire.ɵzoneWrap(firestore.limit, true);
    var limitToLast = fire.ɵzoneWrap(firestore.limitToLast, true);
    var loadBundle = fire.ɵzoneWrap(firestore.loadBundle, true);
    var namedQuery = fire.ɵzoneWrap(firestore.namedQuery, true);
    var onSnapshot = fire.ɵzoneWrap(firestore.onSnapshot, true);
    var onSnapshotsInSync = fire.ɵzoneWrap(firestore.onSnapshotsInSync, true);
    var orderBy = fire.ɵzoneWrap(firestore.orderBy, true);
    var query = fire.ɵzoneWrap(firestore.query, true);
    var queryEqual = fire.ɵzoneWrap(firestore.queryEqual, true);
    var refEqual = fire.ɵzoneWrap(firestore.refEqual, true);
    var runTransaction = fire.ɵzoneWrap(firestore.runTransaction, true);
    var serverTimestamp = fire.ɵzoneWrap(firestore.serverTimestamp, true);
    var setDoc = fire.ɵzoneWrap(firestore.setDoc, true);
    var setLogLevel = fire.ɵzoneWrap(firestore.setLogLevel, true);
    var snapshotEqual = fire.ɵzoneWrap(firestore.snapshotEqual, true);
    var startAfter = fire.ɵzoneWrap(firestore.startAfter, true);
    var startAt = fire.ɵzoneWrap(firestore.startAt, true);
    var terminate = fire.ɵzoneWrap(firestore.terminate, true);
    var updateDoc = fire.ɵzoneWrap(firestore.updateDoc, true);
    var waitForPendingWrites = fire.ɵzoneWrap(firestore.waitForPendingWrites, true);
    var where = fire.ɵzoneWrap(firestore.where, true);
    var writeBatch = fire.ɵzoneWrap(firestore.writeBatch, true);

    /**
     * Generated bundle index. Do not edit.
     */

    exports.Firestore = Firestore;
    exports.FirestoreInstances = FirestoreInstances;
    exports.FirestoreModule = FirestoreModule;
    exports.addDoc = addDoc;
    exports.arrayRemove = arrayRemove;
    exports.arrayUnion = arrayUnion;
    exports.auditTrail = auditTrail;
    exports.clearIndexedDbPersistence = clearIndexedDbPersistence;
    exports.collection = collection;
    exports.collectionChanges = collectionChanges;
    exports.collectionData = collectionData;
    exports.collectionGroup = collectionGroup;
    exports.collectionSnapshots = collectionSnapshots;
    exports.connectFirestoreEmulator = connectFirestoreEmulator;
    exports.deleteDoc = deleteDoc;
    exports.deleteField = deleteField;
    exports.disableNetwork = disableNetwork;
    exports.doc = doc;
    exports.docData = docData;
    exports.docSnapshots = docSnapshots;
    exports.documentId = documentId;
    exports.enableIndexedDbPersistence = enableIndexedDbPersistence;
    exports.enableMultiTabIndexedDbPersistence = enableMultiTabIndexedDbPersistence;
    exports.enableNetwork = enableNetwork;
    exports.endAt = endAt;
    exports.endBefore = endBefore;
    exports.firestoreInstance$ = firestoreInstance$;
    exports.fromRef = fromRef;
    exports.getDoc = getDoc;
    exports.getDocFromCache = getDocFromCache;
    exports.getDocFromServer = getDocFromServer;
    exports.getDocs = getDocs;
    exports.getDocsFromCache = getDocsFromCache;
    exports.getDocsFromServer = getDocsFromServer;
    exports.getFirestore = getFirestore;
    exports.increment = increment;
    exports.initializeFirestore = initializeFirestore;
    exports.limit = limit;
    exports.limitToLast = limitToLast;
    exports.loadBundle = loadBundle;
    exports.namedQuery = namedQuery;
    exports.onSnapshot = onSnapshot;
    exports.onSnapshotsInSync = onSnapshotsInSync;
    exports.orderBy = orderBy;
    exports.provideFirestore = provideFirestore;
    exports.query = query;
    exports.queryEqual = queryEqual;
    exports.refEqual = refEqual;
    exports.runTransaction = runTransaction;
    exports.serverTimestamp = serverTimestamp;
    exports.setDoc = setDoc;
    exports.setLogLevel = setLogLevel;
    exports.snapToData = snapToData;
    exports.snapshotEqual = snapshotEqual;
    exports.sortedChanges = sortedChanges;
    exports.startAfter = startAfter;
    exports.startAt = startAt;
    exports.terminate = terminate;
    exports.updateDoc = updateDoc;
    exports.waitForPendingWrites = waitForPendingWrites;
    exports.where = where;
    exports.writeBatch = writeBatch;
    Object.keys(firestore).forEach(function (k) {
        if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
            enumerable: true,
            get: function () {
                return firestore[k];
            }
        });
    });

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-fire-firestore.umd.js.map
