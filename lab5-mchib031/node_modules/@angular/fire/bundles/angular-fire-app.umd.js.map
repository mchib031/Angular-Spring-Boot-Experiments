{"version":3,"file":"angular-fire-app.umd.js","sources":["../../../src/app/app.ts","../../../src/app/app.module.ts","../../../src/app/firebase.ts","../../../src/app/angular-fire-app.ts"],"sourcesContent":["import { FirebaseApp as IFirebaseApp, getApps } from 'firebase/app';\nimport { from, timer } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\n\n// Need to turn the FirebaseApp interface exported by firebase/app into a class\n// as types don't work in Angular DI. We want developers to be able to inject FirebaseApp like so\n//   constructor(app: FirebaseApp)\n// the cleanest way to achieve this that I found is to export a new interface and class\n// the interface just extends the interface you want to turn into the class. This informs tyepscript\n// that the class has all the same methods/properties as the interface you want to extend without\n// breaking if Firebase adds/removes APIs in future releases. This was a big problem for @angular/fire\n// back when we constructed our own class. Then in the \"new class\" we just return the FirebaseApp in the\n// constructor, this also has the added benefit of Firebase methods taking our DI class without\n// casting. E.g,\n//   constructor(private app: FirebaseApp) { }\n//   ngOnDestroy() { deleteApp(this.app); }\n//\n// tslint:disable-next-line:no-empty-interface\nexport interface FirebaseApp extends IFirebaseApp {}\n\nexport class FirebaseApp {\n  constructor(app: IFirebaseApp) {\n    return app;\n  }\n}\n\nexport interface FirebaseApps extends Array<IFirebaseApp> {}\n\nexport class FirebaseApps {\n  constructor() {\n    return getApps();\n  }\n}\n\nexport const firebaseApp$ = timer(0, 300).pipe(\n  concatMap(() => from(getApps())),\n  distinct(),\n);\n","import {\n  Inject,\n  InjectionToken,\n  ModuleWithProviders,\n  NgModule,\n  NgZone,\n  Optional,\n  PLATFORM_ID,\n  VERSION as NG_VERSION,\n} from '@angular/core';\nimport { FirebaseApp as IFirebaseApp, getApp, registerVersion } from 'firebase/app';\n\nimport { FirebaseApp, FirebaseApps } from './app';\nimport { VERSION, ɵmemoizeInstance, ɵAngularFireSchedulers } from '@angular/fire';\n\nexport function defaultFirebaseAppFactory(provided: FirebaseApp[]|undefined) {\n  // Use the provided app, if there is only one, otherwise fetch the default app\n  if (provided && provided.length === 1) { return provided[0]; }\n  return new FirebaseApp(getApp());\n}\n\n// With FIREBASE_APPS I wanted to capture the default app instance, if it is initialized by\n// the reserved URL; ɵPROVIDED_FIREBASE_APPS is not for public consumption and serves to ensure that all\n// provideFirebaseApp(...) calls are satisfied before FirebaseApp$ or FirebaseApp is resolved\nexport const PROVIDED_FIREBASE_APPS = new InjectionToken<Array<FirebaseApp>>('angularfire2._apps');\n\n// Injecting FirebaseApp will now only inject the default Firebase App\n// this allows allows beginners to import /__/firebase/init.js to auto initialize Firebase App\n// from the reserved URL.\nconst DEFAULT_FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: defaultFirebaseAppFactory,\n  deps: [\n    [new Optional(), PROVIDED_FIREBASE_APPS ],\n  ],\n};\n\nconst FIREBASE_APPS_PROVIDER = {\n  provide: FirebaseApps,\n  deps: [\n    [new Optional(), PROVIDED_FIREBASE_APPS ],\n  ],\n};\n\nexport function firebaseAppFactory(fn: () => IFirebaseApp) {\n  return (zone: NgZone) => {\n    const app = ɵmemoizeInstance<IFirebaseApp>(fn, zone);\n    return new FirebaseApp(app);\n  };\n}\n\n@NgModule({\n  providers: [\n    DEFAULT_FIREBASE_APP_PROVIDER,\n    FIREBASE_APPS_PROVIDER,\n  ]\n})\nexport class FirebaseAppModule {\n  // tslint:disable-next-line:ban-types\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    registerVersion('angularfire', VERSION.full, 'core');\n    registerVersion('angularfire', VERSION.full, 'app');\n    registerVersion('angular', NG_VERSION.full, platformId.toString());\n  }\n}\n\n// Calling initializeApp({ ... }, 'name') multiple times will add more FirebaseApps into the FIREBASE_APPS\n// injection scope. This allows developers to more easily work with multiple Firebase Applications. Downside\n// is that DI for app name and options doesn't really make sense anymore.\nexport function provideFirebaseApp(fn: () => IFirebaseApp): ModuleWithProviders<FirebaseAppModule> {\n  return {\n    ngModule: FirebaseAppModule,\n    providers: [{\n      provide: PROVIDED_FIREBASE_APPS,\n      useFactory: firebaseAppFactory(fn),\n      multi: true,\n      deps: [ NgZone, ɵAngularFireSchedulers ],\n    }],\n  };\n}\n","// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nexport * from 'firebase/app';\nimport { ɵzoneWrap } from '@angular/fire';\nimport {\n  deleteApp as _deleteApp,\n  getApp as _getApp,\n  getApps as _getApps,\n  initializeApp as _initializeApp,\n  onLog as _onLog,\n  registerVersion as _registerVersion,\n  setLogLevel as _setLogLevel\n} from 'firebase/app';\n\nexport const deleteApp = ɵzoneWrap(_deleteApp, true);\nexport const getApp = ɵzoneWrap(_getApp, true);\nexport const getApps = ɵzoneWrap(_getApps, true);\nexport const initializeApp = ɵzoneWrap(_initializeApp, true);\nexport const onLog = ɵzoneWrap(_onLog, true);\nexport const registerVersion = ɵzoneWrap(_registerVersion, true);\nexport const setLogLevel = ɵzoneWrap(_setLogLevel, true);\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["getApps","timer","concatMap","from","distinct","getApp","InjectionToken","Optional","ɵmemoizeInstance","registerVersion","VERSION","NG_VERSION","PLATFORM_ID","NgModule","Inject","NgZone","ɵAngularFireSchedulers","ɵzoneWrap","_deleteApp","_getApp","_getApps","_initializeApp","_onLog","_registerVersion","_setLogLevel"],"mappings":"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"}