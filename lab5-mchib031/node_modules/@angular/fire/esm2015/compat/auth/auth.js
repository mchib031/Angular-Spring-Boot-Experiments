import { Injectable, Inject, Optional, NgZone, PLATFORM_ID, InjectionToken } from '@angular/core';
import { Observable, of, from, merge, Subject } from 'rxjs';
import { switchMap, map, observeOn, shareReplay, first, filter, switchMapTo, subscribeOn } from 'rxjs/operators';
import { ɵAngularFireSchedulers, keepUnstableUntilFirst } from '@angular/fire';
import { ɵlazySDKProxy, ɵapplyMixins } from '@angular/fire/compat';
import { ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';
import { isPlatformServer } from '@angular/common';
import { proxyPolyfillCompat } from './base';
import { ɵcacheInstance } from '@angular/fire';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
export const USE_EMULATOR = new InjectionToken('angularfire2.auth.use-emulator');
export const SETTINGS = new InjectionToken('angularfire2.auth.settings');
export const TENANT_ID = new InjectionToken('angularfire2.auth.tenant-id');
export const LANGUAGE_CODE = new InjectionToken('angularfire2.auth.langugage-code');
export const USE_DEVICE_LANGUAGE = new InjectionToken('angularfire2.auth.use-device-language');
export const PERSISTENCE = new InjectionToken('angularfire.auth.persistence');
export const ɵauthFactory = (app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence) => ɵcacheInstance(`${app.name}.auth`, 'AngularFireAuth', app.name, () => {
    const auth = zone.runOutsideAngular(() => app.auth());
    if (useEmulator) {
        auth.useEmulator(...useEmulator);
    }
    if (tenantId) {
        auth.tenantId = tenantId;
    }
    auth.languageCode = languageCode;
    if (useDeviceLanguage) {
        auth.useDeviceLanguage();
    }
    if (settings) {
        for (const [k, v] of Object.entries(settings)) {
            auth.settings[k] = v;
        }
    }
    if (persistence) {
        auth.setPersistence(persistence);
    }
    return auth;
}, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);
export class AngularFireAuth {
    constructor(options, name, 
    // tslint:disable-next-line:ban-types
    platformId, zone, schedulers, useEmulator, // can't use the tuple here
    settings, // can't use firebase.auth.AuthSettings here
    tenantId, languageCode, useDeviceLanguage, persistence) {
        const logins = new Subject();
        const auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(() => zone.runOutsideAngular(() => import('firebase/compat/auth'))), map(() => ɵfirebaseAppFactory(options, zone, name)), map(app => ɵauthFactory(app, zone, useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence)), shareReplay({ bufferSize: 1, refCount: false }));
        if (isPlatformServer(platformId)) {
            this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);
        }
        else {
            // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth
            //       (e.g, `import { auth } from 'firebase/compat/app'`) are getting an undefined auth object unexpectedly
            //       as we're completely lazy. Let's eagerly load the Auth SDK here.
            //       There could potentially be race conditions still... but this greatly decreases the odds while
            //       we reevaluate the API.
            const _ = auth.pipe(first()).subscribe();
            const redirectResult = auth.pipe(switchMap(auth => auth.getRedirectResult().then(it => it, () => null)), keepUnstableUntilFirst, shareReplay({ bufferSize: 1, refCount: false }));
            const authStateChanged = auth.pipe(switchMap(auth => new Observable(sub => ({ unsubscribe: zone.runOutsideAngular(() => auth.onAuthStateChanged(next => sub.next(next), err => sub.error(err), () => sub.complete())) }))));
            const idTokenChanged = auth.pipe(switchMap(auth => new Observable(sub => ({ unsubscribe: zone.runOutsideAngular(() => auth.onIdTokenChanged(next => sub.next(next), err => sub.error(err), () => sub.complete())) }))));
            this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
            this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
            this.idToken = this.user.pipe(switchMap(user => user ? from(user.getIdToken()) : of(null)));
            this.idTokenResult = this.user.pipe(switchMap(user => user ? from(user.getIdTokenResult()) : of(null)));
            this.credential = merge(redirectResult, logins, 
            // pipe in null authState to make credential zipable, just a weird devexp if
            // authState and user go null to still have a credential
            this.authState.pipe(filter(it => !it))).pipe(
            // handle the { user: { } } when a user is already logged in, rather have null
            // TODO handle the type corcersion better
            map(credential => (credential === null || credential === void 0 ? void 0 : credential.user) ? credential : null), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
        }
        return ɵlazySDKProxy(this, auth, zone, { spy: {
                apply: (name, _, val) => {
                    // If they call a signIn or createUser function listen into the promise
                    // this will give us the user credential, push onto the logins Subject
                    // to be consumed in .credential
                    if (name.startsWith('signIn') || name.startsWith('createUser')) {
                        // TODO fix the types, the trouble is UserCredential has everything optional
                        val.then((user) => logins.next(user));
                    }
                }
            } });
    }
}
AngularFireAuth.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAuth, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: USE_EMULATOR, optional: true }, { token: SETTINGS, optional: true }, { token: TENANT_ID, optional: true }, { token: LANGUAGE_CODE, optional: true }, { token: USE_DEVICE_LANGUAGE, optional: true }, { token: PERSISTENCE, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
AngularFireAuth.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAuth, providedIn: 'any' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: AngularFireAuth, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'any'
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [FIREBASE_OPTIONS]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [FIREBASE_APP_NAME]
                }] }, { type: Object, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [USE_EMULATOR]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SETTINGS]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TENANT_ID]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [LANGUAGE_CODE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [USE_DEVICE_LANGUAGE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PERSISTENCE]
                }] }]; } });
ɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wYXQvYXV0aC9hdXRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRyxPQUFPLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM1RCxPQUFPLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2pILE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMvRSxPQUFPLEVBQUUsYUFBYSxFQUFpQixZQUFZLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLEVBQWUsTUFBTSxzQkFBc0IsQ0FBQztBQUc3RyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDN0MsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0FBSy9DLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBdUIsZ0NBQWdDLENBQUMsQ0FBQztBQUV2RyxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxjQUFjLENBQTZCLDRCQUE0QixDQUFDLENBQUM7QUFDckcsTUFBTSxDQUFDLE1BQU0sU0FBUyxHQUFHLElBQUksY0FBYyxDQUFTLDZCQUE2QixDQUFD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QUFDLENBQUMsSUFBa0MsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFXLENBQUMsQ0FBQyxDQUFDO3FCQUM1RTtnQkFDSCxDQUFDO2FBQ0YsRUFBQyxDQUFDLENBQUM7SUFFTixDQUFDOzs0R0E1SVUsZUFBZSxrQkE4QmhCLGdCQUFnQixhQUNKLGlCQUFpQiw2QkFFN0IsV0FBVyx5RUFHQyxZQUFZLDZCQUNaLFFBQVEsNkJBQ1IsU0FBUyw2QkFDVCxhQUFhLDZCQUNiLG1CQUFtQiw2QkFDbkIsV0FBVztnSEF6Q3RCLGVBQWUsY0FGZCxLQUFLOzJGQUVOLGVBQWU7a0JBSDNCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLEtBQUs7aUJBQ2xCOzswQkErQkksTUFBTTsyQkFBQyxnQkFBZ0I7OzBCQUN2QixRQUFROzswQkFBSSxNQUFNOzJCQUFDLGlCQUFpQjs4QkFFSixNQUFNOzBCQUF0QyxNQUFNOzJCQUFDLFdBQVc7OzBCQUdsQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFlBQVk7OzBCQUMvQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFFBQVE7OzBCQUMzQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFNBQVM7OzBCQUM1QixRQUFROzswQkFBSSxNQUFNOzJCQUFDLGFBQWE7OzBCQUNoQyxRQUFROzswQkFBSSxNQUFNOzJCQUFDLG1CQUFtQjs7MEJBQ3RDLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsV0FBVzs7QUF1R25DLFlBQVksQ0FBQyxlQUFlLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9wdGlvbmFsLCBOZ1pvbmUsIFBMQVRGT1JNX0lELCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIGZyb20sIG1lcmdlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAsIG1hcCwgb2JzZXJ2ZU9uLCBzaGFyZVJlcGxheSwgZmlyc3QsIGZpbHRlciwgc3dpdGNoTWFwVG8sIHN1YnNjcmliZU9uIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMsIGtlZXBVbnN0YWJsZVVudGlsRmlyc3QgfSBmcm9tICdAYW5ndWxhci9maXJlJztcbmltcG9ydCB7IMm1bGF6eVNES1Byb3h5LCDJtVByb21pc2VQcm94eSwgybVhcHBseU1peGlucyB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUvY29tcGF0JztcbmltcG9ydCB7IMm1ZmlyZWJhc2VBcHBGYWN0b3J5LCBGSVJFQkFTRV9PUFRJT05TLCBGSVJFQkFTRV9BUFBfTkFNRSwgRmlyZWJhc2VBcHAgfSBmcm9tICdAYW5ndWxhci9maXJlL2NvbXBhdCc7XG5pbXBvcnQgeyBGaXJlYmFzZU9wdGlvbnMgfSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlL2NvbXBhdC9hcHAnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybVNlcnZlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBwcm94eVBvbHlmaWxsQ29tcGF0IH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IMm1Y2FjaGVJbnN0YW5jZSB9IGZyb20gJ0Bhbmd1bGFyL2ZpcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFuZ3VsYXJGaXJlQXV0aCBleHRlbmRzIMm1UHJvbWlzZVByb3h5PGZpcmViYXNlLmF1dGguQXV0aD4ge31cblxudHlwZSBVc2VFbXVsYXRvckFyZ3VtZW50cyA9IFBhcmFtZXRlcnM8ZmlyZWJhc2UuYXV0aC5BdXRoWyd1c2VFbXVsYXRvciddPjtcbmV4cG9ydCBjb25zdCBVU0VfRU1VTEFUT1IgPSBuZXcgSW5qZWN0aW9uVG9rZW48VXNlRW11bGF0b3JBcmd1bWVudHM+KCdhbmd1bGFyZmlyZTIuYXV0aC51c2UtZW11bGF0b3InKTtcblxuZXhwb3J0IGNvbnN0IFNFVFRJTkdTID0gbmV3IEluamVjdGlvblRva2VuPGZpcmViYXNlLmF1dGguQXV0aFNldHRpbmdzPignYW5ndWxhcmZpcmUyLmF1dGguc2V0dGluZ3MnKTtcbmV4cG9ydCBjb25zdCBURU5BTlRfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignYW5ndWxhcmZpcmUyLmF1dGgudGVuYW50LWlkJyk7XG5leHBvcnQgY29uc3QgTEFOR1VBR0VfQ09ERSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+KCdhbmd1bGFyZmlyZTIuYXV0aC5sYW5ndWdhZ2UtY29kZScpO1xuZXhwb3J0IGNvbnN0IFVTRV9ERVZJQ0VfTEFOR1VBR0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48Ym9vbGVhbj4oJ2FuZ3VsYXJmaXJlMi5hdXRoLnVzZS1kZXZpY2UtbGFuZ3VhZ2UnKTtcbmV4cG9ydCBjb25zdCBQRVJTSVNURU5DRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+KCdhbmd1bGFyZmlyZS5hdXRoLnBlcnNpc3RlbmNlJyk7XG5cbmV4cG9ydCBjb25zdCDJtWF1dGhGYWN0b3J5ID0gKFxuICBhcHA6IEZpcmViYXNlQXBwLCB6b25lOiBOZ1pvbmUsIHVzZUVtdWxhdG9yOiBVc2VFbXVsYXRvckFyZ3VtZW50c3xudWxsLFxuICB0ZW5hbnRJZDogc3RyaW5nLCBsYW5ndWFnZUNvZGU6IHN0cmluZ3xudWxsLCB1c2VEZXZpY2VMYW5ndWFnZTogYm9vbGVhbnxudWxsLFxuICBzZXR0aW5nczogZmlyZWJhc2UuYXV0aC5BdXRoU2V0dGluZ3N8bnVsbCwgcGVyc2lzdGVuY2U6IHN0cmluZ3xudWxsLFxuKSA9PiDJtWNhY2hlSW5zdGFuY2UoYCR7YXBwLm5hbWV9LmF1dGhgLCAnQW5ndWxhckZpcmVBdXRoJywgYXBwLm5hbWUsICgpID0+IHtcbiAgY29uc3QgYXV0aCA9IHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gYXBwLmF1dGgoKSk7XG4gIGlmICh1c2VFbXVsYXRvcikge1xuICAgIGF1dGgudXNlRW11bGF0b3IoLi4udXNlRW11bGF0b3IpO1xuICB9XG4gIGlmICh0ZW5hbnRJZCkge1xuICAgIGF1dGgudGVuYW50SWQgPSB0ZW5hbnRJZDtcbiAgfVxuICBhdXRoLmxhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgaWYgKHVzZURldmljZUxhbmd1YWdlKSB7XG4gICAgYXV0aC51c2VEZXZpY2VMYW5ndWFnZSgpO1xuICB9XG4gIGlmIChzZXR0aW5ncykge1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHNldHRpbmdzKSkge1xuICAgICAgYXV0aC5zZXR0aW5nc1trXSA9IHY7XG4gICAgfVxuICB9XG4gIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgIGF1dGguc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpO1xuICB9XG4gIHJldHVybiBhdXRoO1xufSwgW3VzZUVtdWxhdG9yLCB0ZW5hbnRJZCwgbGFuZ3VhZ2VDb2RlLCB1c2VEZXZpY2VMYW5ndWFnZSwgc2V0dGluZ3MsIHBlcnNpc3RlbmNlXSk7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ2FueSdcbn0pXG5leHBvcnQgY2xhc3MgQW5ndWxhckZpcmVBdXRoIHtcblxuICAvKipcbiAgICogT2JzZXJ2YWJsZSBvZiBhdXRoZW50aWNhdGlvbiBzdGF0ZTsgYXMgb2YgRmlyZWJhc2UgNC4wIHRoaXMgaXMgb25seSB0cmlnZ2VyZWQgdmlhIHNpZ24taW4vb3V0XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgYXV0aFN0YXRlOiBPYnNlcnZhYmxlPGZpcmViYXNlLlVzZXJ8bnVsbD47XG5cbiAgLyoqXG4gICAqIE9ic2VydmFibGUgb2YgdGhlIGN1cnJlbnRseSBzaWduZWQtaW4gdXNlcidzIEpXVCB0b2tlbiB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZSAob3IgbnVsbCkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaWRUb2tlbjogT2JzZXJ2YWJsZTxzdHJpbmd8bnVsbD47XG5cbiAgLyoqXG4gICAqIE9ic2VydmFibGUgb2YgdGhlIGN1cnJlbnRseSBzaWduZWQtaW4gdXNlciAob3IgbnVsbCkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdXNlcjogT2JzZXJ2YWJsZTxmaXJlYmFzZS5Vc2VyfG51bGw+O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlIG9mIHRoZSBjdXJyZW50bHkgc2lnbmVkLWluIHVzZXIncyBJZFRva2VuUmVzdWx0IG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgSUQgdG9rZW4gSldUIHN0cmluZyBhbmQgb3RoZXJcbiAgICogaGVscGVyIHByb3BlcnRpZXMgZm9yIGdldHRpbmcgZGlmZmVyZW50IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSB0b2tlbiBhcyB3ZWxsIGFzIGFsbCB0aGUgZGVjb2RlZCBwYXlsb2FkIGNsYWltc1xuICAgKiAob3IgbnVsbCkuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgaWRUb2tlblJlc3VsdDogT2JzZXJ2YWJsZTxmaXJlYmFzZS5hdXRoLklkVG9rZW5SZXN1bHR8bnVsbD47XG5cbiAgLyoqXG4gICAqIE9ic2VydmFibGUgb2YgdGhlIGN1cnJlbnRseSBzaWduZWQtaW4gdXNlcidzIGNyZWRlbnRpYWwsIG9yIG51bGxcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjcmVkZW50aWFsOiBPYnNlcnZhYmxlPFJlcXVpcmVkPGZpcmViYXNlLmF1dGguVXNlckNyZWRlbnRpYWw+fG51bGw+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoRklSRUJBU0VfT1BUSU9OUykgb3B0aW9uczogRmlyZWJhc2VPcHRpb25zLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRklSRUJBU0VfQVBQX05BTUUpIG5hbWU6IHN0cmluZ3xudWxsfHVuZGVmaW5lZCxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6YmFuLXR5cGVzXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHpvbmU6IE5nWm9uZSxcbiAgICBzY2hlZHVsZXJzOiDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFVTRV9FTVVMQVRPUikgdXNlRW11bGF0b3I6IGFueSwgLy8gY2FuJ3QgdXNlIHRoZSB0dXBsZSBoZXJlXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChTRVRUSU5HUykgc2V0dGluZ3M6IGFueSwgLy8gY2FuJ3QgdXNlIGZpcmViYXNlLmF1dGguQXV0aFNldHRpbmdzIGhlcmVcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFRFTkFOVF9JRCkgdGVuYW50SWQ6IHN0cmluZyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChMQU5HVUFHRV9DT0RFKSBsYW5ndWFnZUNvZGU6IHN0cmluZyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChVU0VfREVWSUNFX0xBTkdVQUdFKSB1c2VEZXZpY2VMYW5ndWFnZTogYm9vbGVhbiB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChQRVJTSVNURU5DRSkgcGVyc2lzdGVuY2U6IHN0cmluZyB8IG51bGwsXG4gICkge1xuICAgIGNvbnN0IGxvZ2lucyA9IG5ldyBTdWJqZWN0PFJlcXVpcmVkPGZpcmViYXNlLmF1dGguVXNlckNyZWRlbnRpYWw+PigpO1xuXG4gICAgY29uc3QgYXV0aCA9IG9mKHVuZGVmaW5lZCkucGlwZShcbiAgICAgIG9ic2VydmVPbihzY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKSxcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IGltcG9ydCgnZmlyZWJhc2UvY29tcGF0L2F1dGgnKSkpLFxuICAgICAgbWFwKCgpID0+IMm1ZmlyZWJhc2VBcHBGYWN0b3J5KG9wdGlvbnMsIHpvbmUsIG5hbWUpKSxcbiAgICAgIG1hcChhcHAgPT4gybVhdXRoRmFjdG9yeShhcHAsIHpvbmUsIHVzZUVtdWxhdG9yLCB0ZW5hbnRJZCwgbGFuZ3VhZ2VDb2RlLCB1c2VEZXZpY2VMYW5ndWFnZSwgc2V0dGluZ3MsIHBlcnNpc3RlbmNlKSksXG4gICAgICBzaGFyZVJlcGxheSh7IGJ1ZmZlclNpemU6IDEsIHJlZkNvdW50OiBmYWxzZSB9KSxcbiAgICApO1xuXG4gICAgaWYgKGlzUGxhdGZvcm1TZXJ2ZXIocGxhdGZvcm1JZCkpIHtcblxuICAgICAgdGhpcy5hdXRoU3RhdGUgPSB0aGlzLnVzZXIgPSB0aGlzLmlkVG9rZW4gPSB0aGlzLmlkVG9rZW5SZXN1bHQgPSB0aGlzLmNyZWRlbnRpYWwgPSBvZihudWxsKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIEhBQ0ssIGFzIHdlJ3JlIGV4cG9ydGluZyBhdXRoLkF1dGgsIHJhdGhlciB0aGFuIGF1dGgsIGRldmVsb3BlcnMgaW1wb3J0aW5nIGZpcmViYXNlLmF1dGhcbiAgICAgIC8vICAgICAgIChlLmcsIGBpbXBvcnQgeyBhdXRoIH0gZnJvbSAnZmlyZWJhc2UvY29tcGF0L2FwcCdgKSBhcmUgZ2V0dGluZyBhbiB1bmRlZmluZWQgYXV0aCBvYmplY3QgdW5leHBlY3RlZGx5XG4gICAgICAvLyAgICAgICBhcyB3ZSdyZSBjb21wbGV0ZWx5IGxhenkuIExldCdzIGVhZ2VybHkgbG9hZCB0aGUgQXV0aCBTREsgaGVyZS5cbiAgICAgIC8vICAgICAgIFRoZXJlIGNvdWxkIHBvdGVudGlhbGx5IGJlIHJhY2UgY29uZGl0aW9ucyBzdGlsbC4uLiBidXQgdGhpcyBncmVhdGx5IGRlY3JlYXNlcyB0aGUgb2RkcyB3aGlsZVxuICAgICAgLy8gICAgICAgd2UgcmVldmFsdWF0ZSB0aGUgQVBJLlxuICAgICAgY29uc3QgXyA9IGF1dGgucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKTtcblxuICAgICAgY29uc3QgcmVkaXJlY3RSZXN1bHQgPSBhdXRoLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcChhdXRoID0+IGF1dGguZ2V0UmVkaXJlY3RSZXN1bHQoKS50aGVuKGl0ID0+IGl0LCAoKSA9PiBudWxsKSksXG4gICAgICAgIGtlZXBVbnN0YWJsZVVudGlsRmlyc3QsXG4gICAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IGZhbHNlIH0pLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgYXV0aFN0YXRlQ2hhbmdlZCA9IGF1dGgucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKGF1dGggPT4gbmV3IE9ic2VydmFibGU8ZmlyZWJhc2UuVXNlcnxudWxsPihzdWIgPT5cbiAgICAgICAgICAoeyB1bnN1YnNjcmliZTogem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBhdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZChcbiAgICAgICAgICAgIG5leHQgPT4gc3ViLm5leHQobmV4dCksXG4gICAgICAgICAgICBlcnIgPT4gc3ViLmVycm9yKGVyciksXG4gICAgICAgICAgICAoKSA9PiBzdWIuY29tcGxldGUoKVxuICAgICAgICAgICkpfSlcbiAgICAgICAgKSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBpZFRva2VuQ2hhbmdlZCA9IGF1dGgucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKGF1dGggPT4gbmV3IE9ic2VydmFibGU8ZmlyZWJhc2UuVXNlcnxudWxsPihzdWIgPT5cbiAgICAgICAgICAoeyB1bnN1YnNjcmliZTogem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBhdXRoLm9uSWRUb2tlbkNoYW5nZWQoXG4gICAgICAgICAgICBuZXh0ID0+IHN1Yi5uZXh0KG5leHQpLFxuICAgICAgICAgICAgZXJyID0+IHN1Yi5lcnJvcihlcnIpLFxuICAgICAgICAgICAgKCkgPT4gc3ViLmNvbXBsZXRlKClcbiAgICAgICAgICApKX0pXG4gICAgICAgICkpXG4gICAgICApO1xuXG4gICAgICB0aGlzLmF1dGhTdGF0ZSA9IHJlZGlyZWN0UmVzdWx0LnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcFRvKGF1dGhTdGF0ZUNoYW5nZWQpLFxuICAgICAgICBzdWJzY3JpYmVPbihzY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKSxcbiAgICAgICAgb2JzZXJ2ZU9uKHNjaGVkdWxlcnMuaW5zaWRlQW5ndWxhciksXG4gICAgICApO1xuXG4gICAgICB0aGlzLnVzZXIgPSByZWRpcmVjdFJlc3VsdC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXBUbyhpZFRva2VuQ2hhbmdlZCksXG4gICAgICAgIHN1YnNjcmliZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5pbnNpZGVBbmd1bGFyKSxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuaWRUb2tlbiA9IHRoaXMudXNlci5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAodXNlciA9PiB1c2VyID8gZnJvbSh1c2VyLmdldElkVG9rZW4oKSkgOiBvZihudWxsKSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuaWRUb2tlblJlc3VsdCA9IHRoaXMudXNlci5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAodXNlciA9PiB1c2VyID8gZnJvbSh1c2VyLmdldElkVG9rZW5SZXN1bHQoKSkgOiBvZihudWxsKSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuY3JlZGVudGlhbCA9IG1lcmdlKFxuICAgICAgICByZWRpcmVjdFJlc3VsdCxcbiAgICAgICAgbG9naW5zLFxuICAgICAgICAvLyBwaXBlIGluIG51bGwgYXV0aFN0YXRlIHRvIG1ha2UgY3JlZGVudGlhbCB6aXBhYmxlLCBqdXN0IGEgd2VpcmQgZGV2ZXhwIGlmXG4gICAgICAgIC8vIGF1dGhTdGF0ZSBhbmQgdXNlciBnbyBudWxsIHRvIHN0aWxsIGhhdmUgYSBjcmVkZW50aWFsXG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnBpcGUoZmlsdGVyKGl0ID0+ICFpdCkpXG4gICAgICApLnBpcGUoXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgeyB1c2VyOiB7IH0gfSB3aGVuIGEgdXNlciBpcyBhbHJlYWR5IGxvZ2dlZCBpbiwgcmF0aGVyIGhhdmUgbnVsbFxuICAgICAgICAvLyBUT0RPIGhhbmRsZSB0aGUgdHlwZSBjb3JjZXJzaW9uIGJldHRlclxuICAgICAgICBtYXAoY3JlZGVudGlhbCA9PiBjcmVkZW50aWFsPy51c2VyID8gY3JlZGVudGlhbCBhcyBSZXF1aXJlZDxmaXJlYmFzZS5hdXRoLlVzZXJDcmVkZW50aWFsPiA6IG51bGwpLFxuICAgICAgICBzdWJzY3JpYmVPbihzY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKSxcbiAgICAgICAgb2JzZXJ2ZU9uKHNjaGVkdWxlcnMuaW5zaWRlQW5ndWxhciksXG4gICAgICApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIMm1bGF6eVNES1Byb3h5KHRoaXMsIGF1dGgsIHpvbmUsIHsgc3B5OiB7XG4gICAgICBhcHBseTogKG5hbWUsIF8sIHZhbCkgPT4ge1xuICAgICAgICAvLyBJZiB0aGV5IGNhbGwgYSBzaWduSW4gb3IgY3JlYXRlVXNlciBmdW5jdGlvbiBsaXN0ZW4gaW50byB0aGUgcHJvbWlzZVxuICAgICAgICAvLyB0aGlzIHdpbGwgZ2l2ZSB1cyB0aGUgdXNlciBjcmVkZW50aWFsLCBwdXNoIG9udG8gdGhlIGxvZ2lucyBTdWJqZWN0XG4gICAgICAgIC8vIHRvIGJlIGNvbnN1bWVkIGluIC5jcmVkZW50aWFsXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3NpZ25JbicpIHx8IG5hbWUuc3RhcnRzV2l0aCgnY3JlYXRlVXNlcicpKSB7XG4gICAgICAgICAgLy8gVE9ETyBmaXggdGhlIHR5cGVzLCB0aGUgdHJvdWJsZSBpcyBVc2VyQ3JlZGVudGlhbCBoYXMgZXZlcnl0aGluZyBvcHRpb25hbFxuICAgICAgICAgIHZhbC50aGVuKCh1c2VyOiBmaXJlYmFzZS5hdXRoLlVzZXJDcmVkZW50aWFsKSA9PiBsb2dpbnMubmV4dCh1c2VyIGFzIGFueSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfX0pO1xuXG4gIH1cblxufVxuXG7JtWFwcGx5TWl4aW5zKEFuZ3VsYXJGaXJlQXV0aCwgW3Byb3h5UG9seWZpbGxDb21wYXRdKTtcbiJdfQ==