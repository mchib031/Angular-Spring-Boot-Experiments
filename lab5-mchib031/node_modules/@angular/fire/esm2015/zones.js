import { Injectable, NgZone } from '@angular/core';
import { asyncScheduler, Observable, queueScheduler } from 'rxjs';
import { observeOn, subscribeOn, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
function noop() {
}
/**
 * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.
 */
// tslint:disable-next-line:class-name
export class ɵZoneScheduler {
    constructor(zone, delegate = queueScheduler) {
        this.zone = zone;
        this.delegate = delegate;
    }
    now() {
        return this.delegate.now();
    }
    schedule(work, delay, state) {
        const targetZone = this.zone;
        // Wrap the specified work function to make sure that if nested scheduling takes place the
        // work is executed in the correct zone
        const workInZone = function (state) {
            targetZone.runGuarded(() => {
                work.apply(this, [state]);
            });
        };
        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done
        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that
        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.
        return this.delegate.schedule(workInZone, delay, state);
    }
}
class BlockUntilFirstOperator {
    constructor(zone) {
        this.zone = zone;
        this.task = null;
    }
    call(subscriber, source) {
        const unscheduleTask = this.unscheduleTask.bind(this);
        this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));
        return source.pipe(tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })).subscribe(subscriber).add(unscheduleTask);
    }
    unscheduleTask() {
        // maybe this is a race condition, invoke in a timeout
        // hold for 10ms while I try to figure out what is going on
        setTimeout(() => {
            if (this.task != null && this.task.state === 'scheduled') {
                this.task.invoke();
                this.task = null;
            }
        }, 10);
    }
}
// tslint:disable-next-line:class-name
export class ɵAngularFireSchedulers {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));
        this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));
        globalThis.ɵAngularFireScheduler || (globalThis.ɵAngularFireScheduler = this);
    }
}
ɵAngularFireSchedulers.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ɵAngularFireSchedulers, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
ɵAngularFireSchedulers.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ɵAngularFireSchedulers, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.3", ngImport: i0, type: ɵAngularFireSchedulers, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });
function getSchedulers() {
    const schedulers = globalThis.ɵAngularFireScheduler;
    if (!schedulers) {
        throw new Error('AngularFireModule has not been provided');
    }
    return schedulers;
}
function runOutsideAngular(fn) {
    return getSchedulers().ngZone.runOutsideAngular(() => fn());
}
function run(fn) {
    return getSchedulers().ngZone.run(() => fn());
}
export function observeOutsideAngular(obs$) {
    return obs$.pipe(observeOn(getSchedulers().outsideAngular));
}
export function observeInsideAngular(obs$) {
    return obs$.pipe(observeOn(getSchedulers().insideAngular));
}
export function keepUnstableUntilFirst(obs$) {
    const scheduler = getSchedulers();
    return ɵkeepUnstableUntilFirstFactory(getSchedulers())(obs$);
}
/**
 * Operator to block the zone until the first value has been emitted or the observable
 * has completed/errored. This is used to make sure that universal waits until the first
 * value from firebase but doesn't block the zone forever since the firebase subscription
 * is still alive.
 */
export function ɵkeepUnstableUntilFirstFactory(schedulers) {
    return function keepUnstableUntilFirst(obs$) {
        obs$ = obs$.lift(new BlockUntilFirstOperator(schedulers.ngZone));
        return obs$.pipe(
        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)
        subscribeOn(schedulers.outsideAngular), 
        // Run operators inside the angular zone (e.g. side effects via tap())
        observeOn(schedulers.insideAngular)
        // INVESTIGATE https://github.com/angular/angularfire/pull/2315
        // share()
        );
    };
}
const zoneWrapFn = (it, macrotask) => {
    const _this = this;
    // function() is needed for the arguments object
    // tslint:disable-next-line:only-arrow-functions
    return function () {
        if (macrotask) {
            setTimeout(() => {
                if (macrotask.state === 'scheduled') {
                    macrotask.invoke();
                }
            }, 10);
        }
        return run(() => it.apply(_this, arguments));
    };
};
export const ɵzoneWrap = (it, blockUntilFirst) => {
    // function() is needed for the arguments object
    // tslint:disable-next-line:only-arrow-functions
    return function () {
        let macrotask;
        // if this is a callback function, e.g, onSnapshot, we should create a microtask and invoke it
        // only once one of the callback functions is tripped.
        for (let i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] === 'function') {
                if (blockUntilFirst) {
                    macrotask || (macrotask = run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));
                }
                // TODO create a microtask to track callback functions
                arguments[i] = zoneWrapFn(arguments[i], macrotask);
            }
        }
        const ret = runOutsideAngular(() => it.apply(this, arguments));
        if (!blockUntilFirst) {
            if (ret instanceof Observable) {
                const schedulers = getSchedulers();
                return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));
            }
            else {
                return run(() => ret);
            }
        }
        if (ret instanceof Observable) {
            return ret.pipe(keepUnstableUntilFirst);
        }
        else if (ret instanceof Promise) {
            return run(() => new Promise((resolve, reject) => ret.then(it => run(() => resolve(it)), reason => run(() => reject(reason)))));
        }
        else if (typeof ret === 'function' && macrotask) {
            // Handle unsubscribe
            // function() is needed for the arguments object
            // tslint:disable-next-line:only-arrow-functions
            return function () {
                setTimeout(() => {
                    if (macrotask && macrotask.state === 'scheduled') {
                        macrotask.invoke();
                    }
                }, 10);
                return ret.apply(this, arguments);
            };
        }
        else {
            // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?
            return run(() => ret);
        }
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiem9uZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvem9uZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUNMLGNBQWMsRUFDZCxVQUFVLEVBRVYsY0FBYyxFQU1mLE1BQU0sTUFBTSxDQUFDO0FBQ2QsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBRTdELFNBQVMsSUFBSTtBQUNiLENBQUM7QUFFRDs7R0FFRztBQUNILHNDQUFzQztBQUN0QyxNQUFNLE9BQU8sY0FBYztJQUN6QixZQUFvQixJQUFTLEVBQVUsV0FBZ0IsY0FBYztRQUFqRCxTQUFJLEdBQUosSUFBSSxDQUFLO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBc0I7SUFDckUsQ0FBQztJQUVELEdBQUc7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVELFFBQVEsQ0FBQyxJQUF1RCxFQUFFLEtBQWMsRUFBRSxLQUFXO1FBQzNGLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDN0IsMEZBQTBGO1FBQzFGLHVDQUF1QztRQUN2QyxNQUFNLFVBQVUsR0FBRyxVQUFxQyxLQUFVO1lBQ2hFLFVBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFO2dCQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7UUFFRixzR0FBc0c7UUFDdEcsaUdBQWlHO1FBQ2pHLCtHQUErRztRQUMvRyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7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LENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDdkI7SUFDSCxDQUFRLENBQUM7QUFDWCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGFzeW5jU2NoZWR1bGVyLFxuICBPYnNlcnZhYmxlLFxuICBPcGVyYXRvcixcbiAgcXVldWVTY2hlZHVsZXIsXG4gIFNjaGVkdWxlckFjdGlvbixcbiAgU2NoZWR1bGVyTGlrZSxcbiAgU3Vic2NyaWJlcixcbiAgU3Vic2NyaXB0aW9uLFxuICBUZWFyZG93bkxvZ2ljXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgb2JzZXJ2ZU9uLCBzdWJzY3JpYmVPbiwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vKipcbiAqIFNjaGVkdWxlcyB0YXNrcyBzbyB0aGF0IHRoZXkgYXJlIGludm9rZWQgaW5zaWRlIHRoZSBab25lIHRoYXQgaXMgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmNsYXNzLW5hbWVcbmV4cG9ydCBjbGFzcyDJtVpvbmVTY2hlZHVsZXIgaW1wbGVtZW50cyBTY2hlZHVsZXJMaWtlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBhbnksIHByaXZhdGUgZGVsZWdhdGU6IGFueSA9IHF1ZXVlU2NoZWR1bGVyKSB7XG4gIH1cblxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubm93KCk7XG4gIH1cblxuICBzY2hlZHVsZSh3b3JrOiAodGhpczogU2NoZWR1bGVyQWN0aW9uPGFueT4sIHN0YXRlPzogYW55KSA9PiB2b2lkLCBkZWxheT86IG51bWJlciwgc3RhdGU/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IHRhcmdldFpvbmUgPSB0aGlzLnpvbmU7XG4gICAgLy8gV3JhcCB0aGUgc3BlY2lmaWVkIHdvcmsgZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoYXQgaWYgbmVzdGVkIHNjaGVkdWxpbmcgdGFrZXMgcGxhY2UgdGhlXG4gICAgLy8gd29yayBpcyBleGVjdXRlZCBpbiB0aGUgY29ycmVjdCB6b25lXG4gICAgY29uc3Qgd29ya0luWm9uZSA9IGZ1bmN0aW9uKHRoaXM6IFNjaGVkdWxlckFjdGlvbjxhbnk+LCBzdGF0ZTogYW55KSB7XG4gICAgICB0YXJnZXRab25lLnJ1bkd1YXJkZWQoKCkgPT4ge1xuICAgICAgICB3b3JrLmFwcGx5KHRoaXMsIFtzdGF0ZV0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFNjaGVkdWxpbmcgaXRzZWxmIG5lZWRzIHRvIGJlIHJ1biBpbiB6b25lIHRvIGVuc3VyZSBzZXRJbnRlcnZhbCBjYWxscyBmb3IgYXN5bmMgc2NoZWR1bGluZyBhcmUgZG9uZVxuICAgIC8vIGluc2lkZSB0aGUgY29ycmVjdCB6b25lLiBUaGlzIHNjaGVkdWxlciBuZWVkcyB0byBzY2hlZHVsZSBhc3luY2hyb25vdXNseSBhbHdheXMgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBmaXJlYmFzZSBlbWlzc2lvbnMgYXJlIG5ldmVyIHN5bmNocm9ub3VzLiBTcGVjaWZ5aW5nIGEgZGVsYXkgY2F1c2VzIGlzc3VlcyB3aXRoIHRoZSBxdWV1ZVNjaGVkdWxlciBkZWxlZ2F0ZS5cbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zY2hlZHVsZSh3b3JrSW5ab25lLCBkZWxheSwgc3RhdGUpO1xuICB9XG59XG5cbmNsYXNzIEJsb2NrVW50aWxGaXJzdE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBwcml2YXRlIHRhc2s6IE1hY3JvVGFzayB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgem9uZTogYW55KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IFRlYXJkb3duTG9naWMge1xuICAgIGNvbnN0IHVuc2NoZWR1bGVUYXNrID0gdGhpcy51bnNjaGVkdWxlVGFzay5iaW5kKHRoaXMpO1xuICAgIHRoaXMudGFzayA9IHRoaXMuem9uZS5ydW4oKCkgPT4gWm9uZS5jdXJyZW50LnNjaGVkdWxlTWFjcm9UYXNrKCdmaXJlYmFzZVpvbmVCbG9jaycsIG5vb3AsIHt9LCBub29wLCBub29wKSk7XG5cbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICB0YXAoeyBuZXh0OiB1bnNjaGVkdWxlVGFzaywgY29tcGxldGU6IHVuc2NoZWR1bGVUYXNrLCBlcnJvcjogdW5zY2hlZHVsZVRhc2sgfSlcbiAgICApLnN1YnNjcmliZShzdWJzY3JpYmVyKS5hZGQodW5zY2hlZHVsZVRhc2spO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnNjaGVkdWxlVGFzaygpIHtcbiAgICAvLyBtYXliZSB0aGlzIGlzIGEgcmFjZSBjb25kaXRpb24sIGludm9rZSBpbiBhIHRpbWVvdXRcbiAgICAvLyBob2xkIGZvciAxMG1zIHdoaWxlIEkgdHJ5IHRvIGZpZ3VyZSBvdXQgd2hhdCBpcyBnb2luZyBvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudGFzayAhPSBudWxsICYmIHRoaXMudGFzay5zdGF0ZSA9PT0gJ3NjaGVkdWxlZCcpIHtcbiAgICAgICAgdGhpcy50YXNrLmludm9rZSgpO1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIDEwKTtcbiAgfVxufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6Y2xhc3MtbmFtZVxuZXhwb3J0IGNsYXNzIMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzIHtcbiAgcHVibGljIHJlYWRvbmx5IG91dHNpZGVBbmd1bGFyOiDJtVpvbmVTY2hlZHVsZXI7XG4gIHB1YmxpYyByZWFkb25seSBpbnNpZGVBbmd1bGFyOiDJtVpvbmVTY2hlZHVsZXI7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG5nWm9uZTogTmdab25lKSB7XG4gICAgdGhpcy5vdXRzaWRlQW5ndWxhciA9IG5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBuZXcgybVab25lU2NoZWR1bGVyKFpvbmUuY3VycmVudCkpO1xuICAgIHRoaXMuaW5zaWRlQW5ndWxhciA9IG5nWm9uZS5ydW4oKCkgPT4gbmV3IMm1Wm9uZVNjaGVkdWxlcihab25lLmN1cnJlbnQsIGFzeW5jU2NoZWR1bGVyKSk7XG4gICAgZ2xvYmFsVGhpcy7JtUFuZ3VsYXJGaXJlU2NoZWR1bGVyIHx8PSB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjaGVkdWxlcnMoKSB7XG4gIGNvbnN0IHNjaGVkdWxlcnMgPSBnbG9iYWxUaGlzLsm1QW5ndWxhckZpcmVTY2hlZHVsZXIgYXMgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnN8dW5kZWZpbmVkO1xuICBpZiAoIXNjaGVkdWxlcnMpIHsgdGhyb3cgbmV3IEVycm9yKCdBbmd1bGFyRmlyZU1vZHVsZSBoYXMgbm90IGJlZW4gcHJvdmlkZWQnKTsgfVxuICByZXR1cm4gc2NoZWR1bGVycztcbn1cblxuZnVuY3Rpb24gcnVuT3V0c2lkZUFuZ3VsYXI8VD4oZm46ICguLi5hcmdzOiBhbnlbXSkgPT4gVCk6IFQge1xuICByZXR1cm4gZ2V0U2NoZWR1bGVycygpLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBmbigpKTtcbn1cblxuZnVuY3Rpb24gcnVuPFQ+KGZuOiAoLi4uYXJnczogYW55W10pID0+IFQpOiBUIHtcbiAgcmV0dXJuIGdldFNjaGVkdWxlcnMoKS5uZ1pvbmUucnVuKCgpID0+IGZuKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZU91dHNpZGVBbmd1bGFyPFQ+KG9icyQ6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIG9icyQucGlwZShvYnNlcnZlT24oZ2V0U2NoZWR1bGVycygpLm91dHNpZGVBbmd1bGFyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlSW5zaWRlQW5ndWxhcjxUPihvYnMkOiBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiBvYnMkLnBpcGUob2JzZXJ2ZU9uKGdldFNjaGVkdWxlcnMoKS5pbnNpZGVBbmd1bGFyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBrZWVwVW5zdGFibGVVbnRpbEZpcnN0PFQ+KG9icyQ6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3Qgc2NoZWR1bGVyID0gZ2V0U2NoZWR1bGVycygpO1xuICByZXR1cm4gybVrZWVwVW5zdGFibGVVbnRpbEZpcnN0RmFjdG9yeShnZXRTY2hlZHVsZXJzKCkpKG9icyQpO1xufVxuXG4vKipcbiAqIE9wZXJhdG9yIHRvIGJsb2NrIHRoZSB6b25lIHVudGlsIHRoZSBmaXJzdCB2YWx1ZSBoYXMgYmVlbiBlbWl0dGVkIG9yIHRoZSBvYnNlcnZhYmxlXG4gKiBoYXMgY29tcGxldGVkL2Vycm9yZWQuIFRoaXMgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhhdCB1bml2ZXJzYWwgd2FpdHMgdW50aWwgdGhlIGZpcnN0XG4gKiB2YWx1ZSBmcm9tIGZpcmViYXNlIGJ1dCBkb2Vzbid0IGJsb2NrIHRoZSB6b25lIGZvcmV2ZXIgc2luY2UgdGhlIGZpcmViYXNlIHN1YnNjcmlwdGlvblxuICogaXMgc3RpbGwgYWxpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KHNjaGVkdWxlcnM6IMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZWVwVW5zdGFibGVVbnRpbEZpcnN0PFQ+KG9icyQ6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBvYnMkID0gb2JzJC5saWZ0KFxuICAgICAgbmV3IEJsb2NrVW50aWxGaXJzdE9wZXJhdG9yKHNjaGVkdWxlcnMubmdab25lKVxuICAgICk7XG5cbiAgICByZXR1cm4gb2JzJC5waXBlKFxuICAgICAgLy8gUnVuIHRoZSBzdWJzY3JpYmUgYm9keSBvdXRzaWRlIG9mIEFuZ3VsYXIgKGUuZy4gY2FsbGluZyBGaXJlYmFzZSBTREsgdG8gYWRkIGEgbGlzdGVuZXIgdG8gYSBjaGFuZ2UgZXZlbnQpXG4gICAgICBzdWJzY3JpYmVPbihzY2hlZHVsZXJzLm91dHNpZGVBbmd1bGFyKSxcbiAgICAgIC8vIFJ1biBvcGVyYXRvcnMgaW5zaWRlIHRoZSBhbmd1bGFyIHpvbmUgKGUuZy4gc2lkZSBlZmZlY3RzIHZpYSB0YXAoKSlcbiAgICAgIG9ic2VydmVPbihzY2hlZHVsZXJzLmluc2lkZUFuZ3VsYXIpXG4gICAgICAvLyBJTlZFU1RJR0FURSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyZmlyZS9wdWxsLzIzMTVcbiAgICAgIC8vIHNoYXJlKClcbiAgICApO1xuICB9O1xufVxuXG5jb25zdCB6b25lV3JhcEZuID0gKGl0OiAoLi4uYXJnczogYW55W10pID0+IGFueSwgbWFjcm90YXNrOiBNYWNyb1Rhc2t8dW5kZWZpbmVkKSA9PiB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgLy8gZnVuY3Rpb24oKSBpcyBuZWVkZWQgZm9yIHRoZSBhcmd1bWVudHMgb2JqZWN0XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvbmx5LWFycm93LWZ1bmN0aW9uc1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG1hY3JvdGFzaykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChtYWNyb3Rhc2suc3RhdGUgPT09ICdzY2hlZHVsZWQnKSB7XG4gICAgICAgICAgbWFjcm90YXNrLmludm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBydW4oKCkgPT4gaXQuYXBwbHkoX3RoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IMm1em9uZVdyYXAgPSA8VD0gdW5rbm93bj4oaXQ6IFQsIGJsb2NrVW50aWxGaXJzdDogYm9vbGVhbik6IFQgPT4ge1xuICAvLyBmdW5jdGlvbigpIGlzIG5lZWRlZCBmb3IgdGhlIGFyZ3VtZW50cyBvYmplY3RcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9ubHktYXJyb3ctZnVuY3Rpb25zXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgbWFjcm90YXNrOiBNYWNyb1Rhc2sgfCB1bmRlZmluZWQ7XG4gICAgLy8gaWYgdGhpcyBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uLCBlLmcsIG9uU25hcHNob3QsIHdlIHNob3VsZCBjcmVhdGUgYSBtaWNyb3Rhc2sgYW5kIGludm9rZSBpdFxuICAgIC8vIG9ubHkgb25jZSBvbmUgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBpcyB0cmlwcGVkLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoYmxvY2tVbnRpbEZpcnN0KSB7XG4gICAgICAgICAgbWFjcm90YXNrIHx8PSBydW4oKCkgPT4gWm9uZS5jdXJyZW50LnNjaGVkdWxlTWFjcm9UYXNrKCdmaXJlYmFzZVpvbmVCbG9jaycsIG5vb3AsIHt9LCBub29wLCBub29wKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBjcmVhdGUgYSBtaWNyb3Rhc2sgdG8gdHJhY2sgY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAgICAgIGFyZ3VtZW50c1tpXSA9IHpvbmVXcmFwRm4oYXJndW1lbnRzW2ldLCBtYWNyb3Rhc2spO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiAoaXQgYXMgYW55KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoIWJsb2NrVW50aWxGaXJzdCkge1xuICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVycyA9IGdldFNjaGVkdWxlcnMoKTtcbiAgICAgICAgcmV0dXJuIHJldC5waXBlKFxuICAgICAgICAgIHN1YnNjcmliZU9uKHNjaGVkdWxlcnMub3V0c2lkZUFuZ3VsYXIpLFxuICAgICAgICAgIG9ic2VydmVPbihzY2hlZHVsZXJzLmluc2lkZUFuZ3VsYXIpLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJ1bigoKSA9PiByZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgcmV0dXJuIHJldC5waXBlKGtlZXBVbnN0YWJsZVVudGlsRmlyc3QpIGFzIGFueTtcbiAgICB9IGVsc2UgaWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiBydW4oKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gcmV0LnRoZW4oaXQgPT4gcnVuKCgpID0+IHJlc29sdmUoaXQpKSwgcmVhc29uID0+IHJ1bigoKSA9PiByZWplY3QocmVhc29uKSkpKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIG1hY3JvdGFzaykge1xuICAgICAgLy8gSGFuZGxlIHVuc3Vic2NyaWJlXG4gICAgICAvLyBmdW5jdGlvbigpIGlzIG5lZWRlZCBmb3IgdGhlIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpvbmx5LWFycm93LWZ1bmN0aW9uc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAobWFjcm90YXNrICYmIG1hY3JvdGFzay5zdGF0ZSA9PT0gJ3NjaGVkdWxlZCcpIHtcbiAgICAgICAgICAgIG1hY3JvdGFzay5pbnZva2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgcmV0dXJuIHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETyBob3cgZG8gd2UgaGFuZGxlIHN0b3JhZ2UgdXBsb2FkcyBpbiBab25lPyBhbmQgb3RoZXIgc3R1ZmYgd2l0aCBjYW5jZWwoKSBldGM/XG4gICAgICByZXR1cm4gcnVuKCgpID0+IHJldCk7XG4gICAgfVxuICB9IGFzIGFueTtcbn07XG4iXX0=