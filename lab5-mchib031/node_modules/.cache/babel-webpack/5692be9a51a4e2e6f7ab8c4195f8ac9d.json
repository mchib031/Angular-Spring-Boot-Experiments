{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Version, isDevMode, Injectable } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { tap, observeOn, subscribeOn } from 'rxjs/operators';\nconst VERSION = new Version('7.0.4');\nconst IS_HMR = !!module.hot;\n\nconst log = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    console[level](...args);\n  }\n};\n\nfunction ɵcacheInstance(cacheKey, moduleName, appName, fn, deps) {\n  const [, instance, cachedDeps] = globalThis.ɵAngularfireInstanceCache.find(it => it[0] === cacheKey) || [];\n\n  if (instance) {\n    if (!matchDep(deps, cachedDeps)) {\n      log('error', `${moduleName} was already initialized on the ${appName} Firebase App with different settings.${IS_HMR ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      log('warn', {\n        is: deps,\n        was: cachedDeps\n      });\n    }\n\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.push([cacheKey, newInstance, deps]);\n    return newInstance;\n  }\n}\n\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = []);\n\nfunction ɵmemoizeInstance(fn, zone) {\n  const [, instance] = globalThis.ɵAngularfireInstanceCache.find(it => matchDep(it[0], fn)) || [];\n\n  if (instance) {\n    return instance;\n  } else {\n    // TODO catch and add HMR warning\n    const instance = zone.runOutsideAngular(() => fn());\n    globalThis.ɵAngularfireInstanceCache.push([fn, instance]);\n    return instance;\n  }\n}\n\nfunction matchDep(a, b) {\n  try {\n    return a.toString() === b.toString();\n  } catch (_) {\n    return a === b;\n  }\n}\n\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n  if (provided) {\n    // Was provide* only called once? If so grab that\n    if (provided.length === 1) {\n      return provided[0];\n    }\n\n    const providedUsingDefaultApp = provided.filter(it => it.app === defaultApp); // Was provide* only called once, using the default app? If so use that\n\n    if (providedUsingDefaultApp.length === 1) {\n      return providedUsingDefaultApp[0];\n    }\n  } // Grab the default instance from the defaultApp\n\n\n  const defaultAppWithContainer = defaultApp;\n  const provider = defaultAppWithContainer.container.getProvider(identifier);\n  return provider.getImmediate();\n}\n\nconst ɵgetAllInstancesOf = (identifier, app) => {\n  const apps = app ? [app] : getApps();\n  const instances = [];\n  apps.forEach(app => {\n    const provider = app.container.getProvider(identifier);\n    provider.instances.forEach(instance => {\n      if (!instances.includes(instance)) {\n        instances.push(instance);\n      }\n    });\n  });\n  return instances;\n};\n\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\n\n\nclass ɵZoneScheduler {\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work, delay, state) {\n    const targetZone = this.zone; // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n\n    const workInZone = function (state) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    }; // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n\n\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n\n}\n\nclass BlockUntilFirstOperator {\n  constructor(zone) {\n    this.zone = zone;\n    this.task = null;\n  }\n\n  call(subscriber, source) {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n    return source.pipe(tap({\n      next: unscheduleTask,\n      complete: unscheduleTask,\n      error: unscheduleTask\n    })).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  unscheduleTask() {\n    // maybe this is a race condition, invoke in a timeout\n    // hold for 10ms while I try to figure out what is going on\n    setTimeout(() => {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }, 10);\n  }\n\n} // tslint:disable-next-line:class-name\n\n\nclass ɵAngularFireSchedulers {\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n    globalThis.ɵAngularFireScheduler || (globalThis.ɵAngularFireScheduler = this);\n  }\n\n}\n\nɵAngularFireSchedulers.ɵfac = function ɵAngularFireSchedulers_Factory(t) {\n  return new (t || ɵAngularFireSchedulers)(i0.ɵɵinject(i0.NgZone));\n};\n\nɵAngularFireSchedulers.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ɵAngularFireSchedulers,\n  factory: ɵAngularFireSchedulers.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵAngularFireSchedulers, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }];\n  }, null);\n})();\n\nfunction getSchedulers() {\n  const schedulers = globalThis.ɵAngularFireScheduler;\n\n  if (!schedulers) {\n    throw new Error('AngularFireModule has not been provided');\n  }\n\n  return schedulers;\n}\n\nfunction runOutsideAngular(fn) {\n  return getSchedulers().ngZone.runOutsideAngular(() => fn());\n}\n\nfunction run(fn) {\n  return getSchedulers().ngZone.run(() => fn());\n}\n\nfunction observeOutsideAngular(obs$) {\n  return obs$.pipe(observeOn(getSchedulers().outsideAngular));\n}\n\nfunction observeInsideAngular(obs$) {\n  return obs$.pipe(observeOn(getSchedulers().insideAngular));\n}\n\nfunction keepUnstableUntilFirst(obs$) {\n  const scheduler = getSchedulers();\n  return ɵkeepUnstableUntilFirstFactory(getSchedulers())(obs$);\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\n\n\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return function keepUnstableUntilFirst(obs$) {\n    obs$ = obs$.lift(new BlockUntilFirstOperator(schedulers.ngZone));\n    return obs$.pipe( // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n    subscribeOn(schedulers.outsideAngular), // Run operators inside the angular zone (e.g. side effects via tap())\n    observeOn(schedulers.insideAngular) // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n    // share()\n    );\n  };\n}\n\nconst zoneWrapFn = (it, macrotask) => {\n  const _this = this; // function() is needed for the arguments object\n  // tslint:disable-next-line:only-arrow-functions\n\n\n  return function () {\n    if (macrotask) {\n      setTimeout(() => {\n        if (macrotask.state === 'scheduled') {\n          macrotask.invoke();\n        }\n      }, 10);\n    }\n\n    return run(() => it.apply(_this, arguments));\n  };\n};\n\nconst ɵzoneWrap = (it, blockUntilFirst) => {\n  // function() is needed for the arguments object\n  // tslint:disable-next-line:only-arrow-functions\n  return function () {\n    let macrotask; // if this is a callback function, e.g, onSnapshot, we should create a microtask and invoke it\n    // only once one of the callback functions is tripped.\n\n    for (let i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] === 'function') {\n        if (blockUntilFirst) {\n          macrotask || (macrotask = run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));\n        } // TODO create a microtask to track callback functions\n\n\n        arguments[i] = zoneWrapFn(arguments[i], macrotask);\n      }\n    }\n\n    const ret = runOutsideAngular(() => it.apply(this, arguments));\n\n    if (!blockUntilFirst) {\n      if (ret instanceof Observable) {\n        const schedulers = getSchedulers();\n        return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      } else {\n        return run(() => ret);\n      }\n    }\n\n    if (ret instanceof Observable) {\n      return ret.pipe(keepUnstableUntilFirst);\n    } else if (ret instanceof Promise) {\n      return run(() => new Promise((resolve, reject) => ret.then(it => run(() => resolve(it)), reason => run(() => reject(reason)))));\n    } else if (typeof ret === 'function' && macrotask) {\n      // Handle unsubscribe\n      // function() is needed for the arguments object\n      // tslint:disable-next-line:only-arrow-functions\n      return function () {\n        setTimeout(() => {\n          if (macrotask && macrotask.state === 'scheduled') {\n            macrotask.invoke();\n          }\n        }, 10);\n        return ret.apply(this, arguments);\n      };\n    } else {\n      // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n      return run(() => ret);\n    }\n  };\n};\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { VERSION, keepUnstableUntilFirst, observeInsideAngular, observeOutsideAngular, ɵAngularFireSchedulers, ɵZoneScheduler, ɵcacheInstance, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵkeepUnstableUntilFirstFactory, ɵmemoizeInstance, ɵzoneWrap };","map":{"version":3,"sources":["/Users/mary/Dropbox/Mac/Documents/lab04/lab04/node_modules/@angular/fire/fesm2015/angular-fire.js"],"names":["i0","Version","isDevMode","Injectable","getApps","queueScheduler","asyncScheduler","Observable","tap","observeOn","subscribeOn","VERSION","IS_HMR","module","hot","log","level","args","console","ɵcacheInstance","cacheKey","moduleName","appName","fn","deps","instance","cachedDeps","globalThis","ɵAngularfireInstanceCache","find","it","matchDep","is","was","newInstance","push","ɵmemoizeInstance","zone","runOutsideAngular","a","b","toString","_","ɵgetDefaultInstanceOf","identifier","provided","defaultApp","length","providedUsingDefaultApp","filter","app","defaultAppWithContainer","provider","container","getProvider","getImmediate","ɵgetAllInstancesOf","apps","instances","forEach","includes","noop","ɵZoneScheduler","constructor","delegate","now","schedule","work","delay","state","targetZone","workInZone","runGuarded","apply","BlockUntilFirstOperator","task","call","subscriber","source","unscheduleTask","bind","run","Zone","current","scheduleMacroTask","pipe","next","complete","error","subscribe","add","setTimeout","invoke","ɵAngularFireSchedulers","ngZone","outsideAngular","insideAngular","ɵAngularFireScheduler","ɵfac","NgZone","ɵprov","type","providedIn","getSchedulers","schedulers","Error","observeOutsideAngular","obs$","observeInsideAngular","keepUnstableUntilFirst","scheduler","ɵkeepUnstableUntilFirstFactory","lift","zoneWrapFn","macrotask","_this","arguments","ɵzoneWrap","blockUntilFirst","i","ret","Promise","resolve","reject","then","reason"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Version, isDevMode, Injectable } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { tap, observeOn, subscribeOn } from 'rxjs/operators';\n\nconst VERSION = new Version('7.0.4');\nconst IS_HMR = !!module.hot;\nconst log = (level, ...args) => {\n    if (isDevMode() && typeof console !== 'undefined') {\n        console[level](...args);\n    }\n};\nfunction ɵcacheInstance(cacheKey, moduleName, appName, fn, deps) {\n    const [, instance, cachedDeps] = globalThis.ɵAngularfireInstanceCache.find((it) => it[0] === cacheKey) || [];\n    if (instance) {\n        if (!matchDep(deps, cachedDeps)) {\n            log('error', `${moduleName} was already initialized on the ${appName} Firebase App with different settings.${IS_HMR ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n            log('warn', { is: deps, was: cachedDeps });\n        }\n        return instance;\n    }\n    else {\n        const newInstance = fn();\n        globalThis.ɵAngularfireInstanceCache.push([cacheKey, newInstance, deps]);\n        return newInstance;\n    }\n}\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = []);\nfunction ɵmemoizeInstance(fn, zone) {\n    const [, instance] = globalThis.ɵAngularfireInstanceCache.find((it) => matchDep(it[0], fn)) || [];\n    if (instance) {\n        return instance;\n    }\n    else {\n        // TODO catch and add HMR warning\n        const instance = zone.runOutsideAngular(() => fn());\n        globalThis.ɵAngularfireInstanceCache.push([fn, instance]);\n        return instance;\n    }\n}\nfunction matchDep(a, b) {\n    try {\n        return a.toString() === b.toString();\n    }\n    catch (_) {\n        return a === b;\n    }\n}\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n    if (provided) {\n        // Was provide* only called once? If so grab that\n        if (provided.length === 1) {\n            return provided[0];\n        }\n        const providedUsingDefaultApp = provided.filter((it) => it.app === defaultApp);\n        // Was provide* only called once, using the default app? If so use that\n        if (providedUsingDefaultApp.length === 1) {\n            return providedUsingDefaultApp[0];\n        }\n    }\n    // Grab the default instance from the defaultApp\n    const defaultAppWithContainer = defaultApp;\n    const provider = defaultAppWithContainer.container.getProvider(identifier);\n    return provider.getImmediate();\n}\nconst ɵgetAllInstancesOf = (identifier, app) => {\n    const apps = app ? [app] : getApps();\n    const instances = [];\n    apps.forEach((app) => {\n        const provider = app.container.getProvider(identifier);\n        provider.instances.forEach((instance) => {\n            if (!instances.includes(instance)) {\n                instances.push(instance);\n            }\n        });\n    });\n    return instances;\n};\n\nfunction noop() {\n}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\nclass ɵZoneScheduler {\n    constructor(zone, delegate = queueScheduler) {\n        this.zone = zone;\n        this.delegate = delegate;\n    }\n    now() {\n        return this.delegate.now();\n    }\n    schedule(work, delay, state) {\n        const targetZone = this.zone;\n        // Wrap the specified work function to make sure that if nested scheduling takes place the\n        // work is executed in the correct zone\n        const workInZone = function (state) {\n            targetZone.runGuarded(() => {\n                work.apply(this, [state]);\n            });\n        };\n        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n        return this.delegate.schedule(workInZone, delay, state);\n    }\n}\nclass BlockUntilFirstOperator {\n    constructor(zone) {\n        this.zone = zone;\n        this.task = null;\n    }\n    call(subscriber, source) {\n        const unscheduleTask = this.unscheduleTask.bind(this);\n        this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n        return source.pipe(tap({ next: unscheduleTask, complete: unscheduleTask, error: unscheduleTask })).subscribe(subscriber).add(unscheduleTask);\n    }\n    unscheduleTask() {\n        // maybe this is a race condition, invoke in a timeout\n        // hold for 10ms while I try to figure out what is going on\n        setTimeout(() => {\n            if (this.task != null && this.task.state === 'scheduled') {\n                this.task.invoke();\n                this.task = null;\n            }\n        }, 10);\n    }\n}\n// tslint:disable-next-line:class-name\nclass ɵAngularFireSchedulers {\n    constructor(ngZone) {\n        this.ngZone = ngZone;\n        this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n        this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n        globalThis.ɵAngularFireScheduler || (globalThis.ɵAngularFireScheduler = this);\n    }\n}\nɵAngularFireSchedulers.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: ɵAngularFireSchedulers, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });\nɵAngularFireSchedulers.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: ɵAngularFireSchedulers, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: ɵAngularFireSchedulers, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });\nfunction getSchedulers() {\n    const schedulers = globalThis.ɵAngularFireScheduler;\n    if (!schedulers) {\n        throw new Error('AngularFireModule has not been provided');\n    }\n    return schedulers;\n}\nfunction runOutsideAngular(fn) {\n    return getSchedulers().ngZone.runOutsideAngular(() => fn());\n}\nfunction run(fn) {\n    return getSchedulers().ngZone.run(() => fn());\n}\nfunction observeOutsideAngular(obs$) {\n    return obs$.pipe(observeOn(getSchedulers().outsideAngular));\n}\nfunction observeInsideAngular(obs$) {\n    return obs$.pipe(observeOn(getSchedulers().insideAngular));\n}\nfunction keepUnstableUntilFirst(obs$) {\n    const scheduler = getSchedulers();\n    return ɵkeepUnstableUntilFirstFactory(getSchedulers())(obs$);\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n    return function keepUnstableUntilFirst(obs$) {\n        obs$ = obs$.lift(new BlockUntilFirstOperator(schedulers.ngZone));\n        return obs$.pipe(\n        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n        subscribeOn(schedulers.outsideAngular), \n        // Run operators inside the angular zone (e.g. side effects via tap())\n        observeOn(schedulers.insideAngular)\n        // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n        // share()\n        );\n    };\n}\nconst zoneWrapFn = (it, macrotask) => {\n    const _this = this;\n    // function() is needed for the arguments object\n    // tslint:disable-next-line:only-arrow-functions\n    return function () {\n        if (macrotask) {\n            setTimeout(() => {\n                if (macrotask.state === 'scheduled') {\n                    macrotask.invoke();\n                }\n            }, 10);\n        }\n        return run(() => it.apply(_this, arguments));\n    };\n};\nconst ɵzoneWrap = (it, blockUntilFirst) => {\n    // function() is needed for the arguments object\n    // tslint:disable-next-line:only-arrow-functions\n    return function () {\n        let macrotask;\n        // if this is a callback function, e.g, onSnapshot, we should create a microtask and invoke it\n        // only once one of the callback functions is tripped.\n        for (let i = 0; i < arguments.length; i++) {\n            if (typeof arguments[i] === 'function') {\n                if (blockUntilFirst) {\n                    macrotask || (macrotask = run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));\n                }\n                // TODO create a microtask to track callback functions\n                arguments[i] = zoneWrapFn(arguments[i], macrotask);\n            }\n        }\n        const ret = runOutsideAngular(() => it.apply(this, arguments));\n        if (!blockUntilFirst) {\n            if (ret instanceof Observable) {\n                const schedulers = getSchedulers();\n                return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n            }\n            else {\n                return run(() => ret);\n            }\n        }\n        if (ret instanceof Observable) {\n            return ret.pipe(keepUnstableUntilFirst);\n        }\n        else if (ret instanceof Promise) {\n            return run(() => new Promise((resolve, reject) => ret.then(it => run(() => resolve(it)), reason => run(() => reject(reason)))));\n        }\n        else if (typeof ret === 'function' && macrotask) {\n            // Handle unsubscribe\n            // function() is needed for the arguments object\n            // tslint:disable-next-line:only-arrow-functions\n            return function () {\n                setTimeout(() => {\n                    if (macrotask && macrotask.state === 'scheduled') {\n                        macrotask.invoke();\n                    }\n                }, 10);\n                return ret.apply(this, arguments);\n            };\n        }\n        else {\n            // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n            return run(() => ret);\n        }\n    };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { VERSION, keepUnstableUntilFirst, observeInsideAngular, observeOutsideAngular, ɵAngularFireSchedulers, ɵZoneScheduler, ɵcacheInstance, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵkeepUnstableUntilFirstFactory, ɵmemoizeInstance, ɵzoneWrap };\n"]},"metadata":{},"sourceType":"module"}