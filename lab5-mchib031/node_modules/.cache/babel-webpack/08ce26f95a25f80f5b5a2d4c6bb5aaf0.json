{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, ɵcacheInstance, VERSION } from '@angular/fire';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter } from 'rxjs/operators';\nimport { ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport { isPlatformServer } from '@angular/common';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS as SETTINGS$1, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport firebase from 'firebase/compat/app';\n\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n  return new Observable(subscriber => {\n    let unsubscribe;\n\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({\n          includeMetadataChanges: true\n        }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({\n        includeMetadataChanges: true\n      }, subscriber);\n    }\n\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\n\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\n\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(startWith(undefined), pairwise(), map(([priorPayload, payload]) => {\n    if (!payload.exists) {\n      return {\n        payload,\n        type: 'removed'\n      };\n    }\n\n    if (!(priorPayload === null || priorPayload === void 0 ? void 0 : priorPayload.exists)) {\n      return {\n        payload,\n        type: 'added'\n      };\n    }\n\n    return {\n      payload,\n      type: 'modified'\n    };\n  }));\n}\n\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(payload => ({\n    payload,\n    type: 'query'\n  })));\n}\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\n\n\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(startWith(undefined), pairwise(), map(([priorAction, action]) => {\n    const docChanges = action.payload.docChanges();\n    const actions = docChanges.map(change => ({\n      type: change.type,\n      payload: change\n    })); // the metadata has changed from the prior emission\n\n    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n      // go through all the docs in payload and figure out which ones changed\n      action.payload.docs.forEach((currentDoc, currentIndex) => {\n        const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n        const priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n\n        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {// document doesn't appear to have changed, don't log another action\n        } else {\n          // since the actions are processed in order just push onto the array\n          actions.push({\n            type: 'modified',\n            payload: {\n              oldIndex: currentIndex,\n              newIndex: currentIndex,\n              type: 'modified',\n              doc: currentDoc\n            }\n          });\n        }\n      });\n    }\n\n    return actions;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\n\n\nfunction sortedChanges(query, events, scheduler) {\n  return docChanges(query, scheduler).pipe(scan((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), distinctUntilChanged(), // cut down on unneed change cycles\n  map(changes => changes.map(c => ({\n    type: c.type,\n    payload: c\n  }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\n\n\nfunction combineChanges(current, changes, events) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount, ...args) {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\n\n\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {// Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n\nfunction validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\n\n\nclass AngularFirestoreCollection {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(ref, query, afs) {\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n\n\n  stateChanges(events) {\n    let source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n\n    if (events && events.length > 0) {\n      source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));\n    }\n\n    return source.pipe( // We want to filter out empty arrays, but always emit at first, so the developer knows\n    // that the collection has been resolve; even if it's empty\n    startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([prior, current]) => current), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n\n\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n\n\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n\n  valueChanges(options = {}) {\n    return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return Object.assign(Object.assign({}, a.data()), {\n          [options.idField]: a.id\n        });\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n\n\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n\n\n  add(data) {\n    return this.ref.add(data);\n  }\n  /**\n   * Create a reference to a single document in a collection.\n   */\n\n\n  doc(path) {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n  }\n\n}\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\n\n\nclass AngularFirestoreDocument {\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(ref, afs) {\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   */\n\n\n  set(data, options) {\n    return this.ref.set(data, options);\n  }\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n\n\n  update(data) {\n    return this.ref.update(data);\n  }\n  /**\n   * Delete a document.\n   */\n\n\n  delete() {\n    return this.ref.delete();\n  }\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n\n\n  collection(path, queryFn) {\n    const collectionRef = this.ref.collection(path);\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n  /**\n   * Listen to snapshot updates from the document.\n   */\n\n\n  snapshotChanges() {\n    const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(keepUnstableUntilFirst);\n  }\n\n  valueChanges(options = {}) {\n    return this.snapshotChanges().pipe(map(({\n      payload\n    }) => options.idField ? Object.assign(Object.assign({}, payload.data()), {\n      [options.idField]: payload.id\n    }) : payload.data()));\n  }\n  /**\n   * Retrieve the document once.\n   */\n\n\n  get(options) {\n    return from(this.ref.get(options)).pipe(keepUnstableUntilFirst);\n  }\n\n}\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\n\n\nclass AngularFirestoreCollectionGroup {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(query, afs) {\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n\n\n  stateChanges(events) {\n    if (!events || events.length === 0) {\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(keepUnstableUntilFirst);\n    }\n\n    return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)), filter(changes => changes.length > 0), keepUnstableUntilFirst);\n  }\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n\n\n  auditTrail(events) {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n\n\n  snapshotChanges(events) {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n  }\n\n  valueChanges(options = {}) {\n    const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$.pipe(map(actions => actions.payload.docs.map(a => {\n      if (options.idField) {\n        return Object.assign({\n          [options.idField]: a.id\n        }, a.data());\n      } else {\n        return a.data();\n      }\n    })), keepUnstableUntilFirst);\n  }\n  /**\n   * Retrieve the results of the query once.\n   */\n\n\n  get(options) {\n    return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n  }\n\n}\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\n\n\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\nconst USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\n\nfunction associateQuery(collectionRef, queryFn = ref => ref) {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return {\n    query,\n    ref\n  };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n\n\nclass AngularFirestore {\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(options, name, shouldEnablePersistence, settings, // tslint:disable-next-line:ban-types\n  platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here\n  tenantId, languageCode, useDeviceLanguage, persistence) {\n    this.schedulers = schedulers;\n    const app = ɵfirebaseAppFactory(options, zone, name);\n    const useEmulator = _useEmulator;\n\n    if (auth) {\n      ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n    }\n\n    [this.firestore, this.persistenceEnabled$] = ɵcacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n      const firestore = zone.runOutsideAngular(() => app.firestore());\n\n      if (settings) {\n        firestore.settings(settings);\n      }\n\n      if (useEmulator) {\n        firestore.useEmulator(...useEmulator);\n      }\n\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n        const enablePersistence = () => {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n          } catch (e) {\n            if (typeof console !== 'undefined') {\n              console.warn(e);\n            }\n\n            return of(false);\n          }\n        };\n\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n    }, [settings, useEmulator, shouldEnablePersistence]);\n  }\n\n  collection(pathOrRef, queryFn) {\n    let collectionRef;\n\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n\n    const {\n      ref,\n      query\n    } = associateQuery(collectionRef, queryFn);\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreCollection(refInZone, query, this);\n  }\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n\n\n  collectionGroup(collectionId, queryGroupFn) {\n    const queryFn = queryGroupFn || (ref => ref);\n\n    const collectionGroup = this.firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n  }\n\n  doc(pathOrRef) {\n    let ref;\n\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n\n    const refInZone = this.schedulers.ngZone.run(() => ref);\n    return new AngularFirestoreDocument(refInZone, this);\n  }\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n\n\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n\n}\n\nAngularFirestore.ɵfac = function AngularFirestore_Factory(t) {\n  return new (t || AngularFirestore)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(ENABLE_PERSISTENCE, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(PERSISTENCE_SETTINGS, 8), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AngularFireAuth, 8), i0.ɵɵinject(USE_EMULATOR$1, 8), i0.ɵɵinject(SETTINGS$1, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8));\n};\n\nAngularFirestore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: AngularFirestore,\n  factory: AngularFirestore.ɵfac,\n  providedIn: 'any'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFirestore, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'any'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ENABLE_PERSISTENCE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SETTINGS]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: i0.NgZone\n    }, {\n      type: i1.ɵAngularFireSchedulers\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [PERSISTENCE_SETTINGS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [USE_EMULATOR]\n      }]\n    }, {\n      type: i2.AngularFireAuth,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [USE_EMULATOR$1]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SETTINGS$1]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [TENANT_ID]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [LANGUAGE_CODE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [USE_DEVICE_LANGUAGE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [PERSISTENCE]\n      }]\n    }];\n  }, null);\n})();\n\nclass AngularFirestoreModule {\n  constructor() {\n    firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n  }\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n\n\n  static enablePersistence(persistenceSettings) {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [{\n        provide: ENABLE_PERSISTENCE,\n        useValue: true\n      }, {\n        provide: PERSISTENCE_SETTINGS,\n        useValue: persistenceSettings\n      }]\n    };\n  }\n\n}\n\nAngularFirestoreModule.ɵfac = function AngularFirestoreModule_Factory(t) {\n  return new (t || AngularFirestoreModule)();\n};\n\nAngularFirestoreModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: AngularFirestoreModule\n});\nAngularFirestoreModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [AngularFirestore]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFirestoreModule, [{\n    type: NgModule,\n    args: [{\n      providers: [AngularFirestore]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };","map":{"version":3,"sources":["/Users/mary/Dropbox/Mac/Documents/lab04/lab04/node_modules/@angular/fire/fesm2015/angular-fire-compat-firestore.js"],"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Optional","NgModule","asyncScheduler","Observable","from","of","i1","keepUnstableUntilFirst","ɵcacheInstance","VERSION","startWith","pairwise","map","scan","distinctUntilChanged","filter","ɵfirebaseAppFactory","FIREBASE_OPTIONS","FIREBASE_APP_NAME","isPlatformServer","i2","ɵauthFactory","USE_EMULATOR","USE_EMULATOR$1","SETTINGS","SETTINGS$1","TENANT_ID","LANGUAGE_CODE","USE_DEVICE_LANGUAGE","PERSISTENCE","firebase","_fromRef","ref","scheduler","subscriber","unsubscribe","schedule","onSnapshot","includeMetadataChanges","fromRef","fromDocRef","pipe","undefined","priorPayload","payload","exists","type","fromCollectionRef","docChanges","query","priorAction","action","actions","change","JSON","stringify","metadata","docs","forEach","currentDoc","currentIndex","docChange","find","d","doc","isEqual","priorDoc","push","oldIndex","newIndex","sortedChanges","events","current","changes","combineChanges","it","c","indexOf","combineChange","sliceAndSplice","original","start","deleteCount","args","returnArray","slice","splice","combined","copiedArray","validateEventsArray","length","AngularFirestoreCollection","constructor","afs","stateChanges","source","schedulers","outsideAngular","prior","auditTrail","snapshotChanges","validatedEvents","scheduledSortedChanges$","valueChanges","options","a","idField","Object","assign","data","id","get","add","path","AngularFirestoreDocument","set","update","delete","collection","queryFn","collectionRef","associateQuery","scheduledFromDocRef$","AngularFirestoreCollectionGroup","fromCollectionRefScheduled$","ENABLE_PERSISTENCE","PERSISTENCE_SETTINGS","AngularFirestore","name","shouldEnablePersistence","settings","platformId","zone","persistenceSettings","_useEmulator","auth","useAuthEmulator","authSettings","tenantId","languageCode","useDeviceLanguage","persistence","app","useEmulator","firestore","persistenceEnabled$","runOutsideAngular","enablePersistence","then","e","console","warn","pathOrRef","refInZone","ngZone","run","collectionGroup","collectionId","queryGroupFn","createId","ɵfac","NgZone","ɵAngularFireSchedulers","AngularFireAuth","ɵprov","providedIn","decorators","AngularFirestoreModule","registerVersion","full","ngModule","providers","provide","useValue","ɵmod","ɵinj"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, ɵcacheInstance, VERSION } from '@angular/fire';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter } from 'rxjs/operators';\nimport { ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport { isPlatformServer } from '@angular/common';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS as SETTINGS$1, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport firebase from 'firebase/compat/app';\n\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n    return new Observable(subscriber => {\n        let unsubscribe;\n        if (scheduler != null) {\n            scheduler.schedule(() => {\n                unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n            });\n        }\n        else {\n            unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n        }\n        return () => {\n            if (unsubscribe != null) {\n                unsubscribe();\n            }\n        };\n    });\n}\nfunction fromRef(ref, scheduler) {\n    return _fromRef(ref, scheduler);\n}\nfunction fromDocRef(ref, scheduler) {\n    return fromRef(ref, scheduler)\n        .pipe(startWith(undefined), pairwise(), map(([priorPayload, payload]) => {\n        if (!payload.exists) {\n            return { payload, type: 'removed' };\n        }\n        if (!(priorPayload === null || priorPayload === void 0 ? void 0 : priorPayload.exists)) {\n            return { payload, type: 'added' };\n        }\n        return { payload, type: 'modified' };\n    }));\n}\nfunction fromCollectionRef(ref, scheduler) {\n    return fromRef(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nfunction docChanges(query, scheduler) {\n    return fromCollectionRef(query, scheduler)\n        .pipe(startWith(undefined), pairwise(), map(([priorAction, action]) => {\n        const docChanges = action.payload.docChanges();\n        const actions = docChanges.map(change => ({ type: change.type, payload: change }));\n        // the metadata has changed from the prior emission\n        if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n            // go through all the docs in payload and figure out which ones changed\n            action.payload.docs.forEach((currentDoc, currentIndex) => {\n                const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n                const priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n                if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) ||\n                    !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n                    // document doesn't appear to have changed, don't log another action\n                }\n                else {\n                    // since the actions are processed in order just push onto the array\n                    actions.push({\n                        type: 'modified',\n                        payload: {\n                            oldIndex: currentIndex,\n                            newIndex: currentIndex,\n                            type: 'modified',\n                            doc: currentDoc\n                        }\n                    });\n                }\n            });\n        }\n        return actions;\n    }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nfunction sortedChanges(query, events, scheduler) {\n    return docChanges(query, scheduler)\n        .pipe(scan((current, changes) => combineChanges(current, changes.map(it => it.payload), events), []), distinctUntilChanged(), // cut down on unneed change cycles\n    map(changes => changes.map(c => ({ type: c.type, payload: c }))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nfunction combineChanges(current, changes, events) {\n    changes.forEach(change => {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = combineChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount, ...args) {\n    const returnArray = original.slice();\n    returnArray.splice(start, deleteCount, ...args);\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nfunction combineChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n                // Not sure why the duplicates are getting fired\n            }\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    const copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n    }\n    return combined;\n}\n\nfunction validateEventsArray(events) {\n    if (!events || events.length === 0) {\n        events = ['added', 'removed', 'modified'];\n    }\n    return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollection {\n    /**\n     * The constructor takes in a CollectionReference and Query to provide wrapper methods\n     * for data operations and data streaming.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query. See the AssociatedRefence type for details\n     * on this implication.\n     */\n    constructor(ref, query, afs) {\n        this.ref = ref;\n        this.query = query;\n        this.afs = afs;\n    }\n    /**\n     * Listen to the latest change in the stream. This method returns changes\n     * as they occur and they are not sorted by query order. This allows you to construct\n     * your own data structure.\n     */\n    stateChanges(events) {\n        let source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n        if (events && events.length > 0) {\n            source = source.pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)));\n        }\n        return source.pipe(\n        // We want to filter out empty arrays, but always emit at first, so the developer knows\n        // that the collection has been resolve; even if it's empty\n        startWith(undefined), pairwise(), filter(([prior, current]) => current.length > 0 || !prior), map(([prior, current]) => current), keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     */\n    auditTrail(events) {\n        return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     */\n    snapshotChanges(events) {\n        const validatedEvents = validateEventsArray(events);\n        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n        return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n    }\n    valueChanges(options = {}) {\n        return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular)\n            .pipe(map(actions => actions.payload.docs.map(a => {\n            if (options.idField) {\n                return Object.assign(Object.assign({}, a.data()), { [options.idField]: a.id });\n            }\n            else {\n                return a.data();\n            }\n        })), keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     */\n    get(options) {\n        return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n    }\n    /**\n     * Add data to a collection reference.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query.\n     */\n    add(data) {\n        return this.ref.add(data);\n    }\n    /**\n     * Create a reference to a single document in a collection.\n     */\n    doc(path) {\n        // TODO is there a better way to solve this type issue\n        return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n    }\n}\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nclass AngularFirestoreDocument {\n    /**\n     * The constructor takes in a DocumentReference to provide wrapper methods\n     * for data operations, data streaming, and Symbol.observable.\n     */\n    constructor(ref, afs) {\n        this.ref = ref;\n        this.afs = afs;\n    }\n    /**\n     * Create or overwrite a single document.\n     */\n    set(data, options) {\n        return this.ref.set(data, options);\n    }\n    /**\n     * Update some fields of a document without overwriting the entire document.\n     */\n    update(data) {\n        return this.ref.update(data);\n    }\n    /**\n     * Delete a document.\n     */\n    delete() {\n        return this.ref.delete();\n    }\n    /**\n     * Create a reference to a sub-collection given a path and an optional query\n     * function.\n     */\n    collection(path, queryFn) {\n        const collectionRef = this.ref.collection(path);\n        const { ref, query } = associateQuery(collectionRef, queryFn);\n        return new AngularFirestoreCollection(ref, query, this.afs);\n    }\n    /**\n     * Listen to snapshot updates from the document.\n     */\n    snapshotChanges() {\n        const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n        return scheduledFromDocRef$.pipe(keepUnstableUntilFirst);\n    }\n    valueChanges(options = {}) {\n        return this.snapshotChanges().pipe(map(({ payload }) => options.idField ? Object.assign(Object.assign({}, payload.data()), { [options.idField]: payload.id }) : payload.data()));\n    }\n    /**\n     * Retrieve the document once.\n     */\n    get(options) {\n        return from(this.ref.get(options)).pipe(keepUnstableUntilFirst);\n    }\n}\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nclass AngularFirestoreCollectionGroup {\n    /**\n     * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n     * for data operations and data streaming.\n     */\n    constructor(query, afs) {\n        this.query = query;\n        this.afs = afs;\n    }\n    /**\n     * Listen to the latest change in the stream. This method returns changes\n     * as they occur and they are not sorted by query order. This allows you to construct\n     * your own data structure.\n     */\n    stateChanges(events) {\n        if (!events || events.length === 0) {\n            return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(keepUnstableUntilFirst);\n        }\n        return docChanges(this.query, this.afs.schedulers.outsideAngular)\n            .pipe(map(actions => actions.filter(change => events.indexOf(change.type) > -1)), filter(changes => changes.length > 0), keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     */\n    auditTrail(events) {\n        return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     */\n    snapshotChanges(events) {\n        const validatedEvents = validateEventsArray(events);\n        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n        return scheduledSortedChanges$.pipe(keepUnstableUntilFirst);\n    }\n    valueChanges(options = {}) {\n        const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n        return fromCollectionRefScheduled$\n            .pipe(map(actions => actions.payload.docs.map(a => {\n            if (options.idField) {\n                return Object.assign({ [options.idField]: a.id }, a.data());\n            }\n            else {\n                return a.data();\n            }\n        })), keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     */\n    get(options) {\n        return from(this.query.get(options)).pipe(keepUnstableUntilFirst);\n    }\n}\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\nconst USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nfunction associateQuery(collectionRef, queryFn = ref => ref) {\n    const query = queryFn(collectionRef);\n    const ref = collectionRef;\n    return { query, ref };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\nclass AngularFirestore {\n    /**\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\n     * don't rely on the main Firebase App instance and we can create named\n     * apps and use multiple apps.\n     */\n    constructor(options, name, shouldEnablePersistence, settings, \n    // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, persistenceSettings, _useEmulator, auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence) {\n        this.schedulers = schedulers;\n        const app = ɵfirebaseAppFactory(options, zone, name);\n        const useEmulator = _useEmulator;\n        if (auth) {\n            ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n        }\n        [this.firestore, this.persistenceEnabled$] = ɵcacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n            const firestore = zone.runOutsideAngular(() => app.firestore());\n            if (settings) {\n                firestore.settings(settings);\n            }\n            if (useEmulator) {\n                firestore.useEmulator(...useEmulator);\n            }\n            if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n                // We need to try/catch here because not all enablePersistence() failures are caught\n                // https://github.com/firebase/firebase-js-sdk/issues/608\n                const enablePersistence = () => {\n                    try {\n                        return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n                    }\n                    catch (e) {\n                        if (typeof console !== 'undefined') {\n                            console.warn(e);\n                        }\n                        return of(false);\n                    }\n                };\n                return [firestore, zone.runOutsideAngular(enablePersistence)];\n            }\n            else {\n                return [firestore, of(false)];\n            }\n        }, [settings, useEmulator, shouldEnablePersistence]);\n    }\n    collection(pathOrRef, queryFn) {\n        let collectionRef;\n        if (typeof pathOrRef === 'string') {\n            collectionRef = this.firestore.collection(pathOrRef);\n        }\n        else {\n            collectionRef = pathOrRef;\n        }\n        const { ref, query } = associateQuery(collectionRef, queryFn);\n        const refInZone = this.schedulers.ngZone.run(() => ref);\n        return new AngularFirestoreCollection(refInZone, query, this);\n    }\n    /**\n     * Create a reference to a Firestore Collection Group based on a collectionId\n     * and an optional query function to narrow the result\n     * set.\n     */\n    collectionGroup(collectionId, queryGroupFn) {\n        const queryFn = queryGroupFn || (ref => ref);\n        const collectionGroup = this.firestore.collectionGroup(collectionId);\n        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n    }\n    doc(pathOrRef) {\n        let ref;\n        if (typeof pathOrRef === 'string') {\n            ref = this.firestore.doc(pathOrRef);\n        }\n        else {\n            ref = pathOrRef;\n        }\n        const refInZone = this.schedulers.ngZone.run(() => ref);\n        return new AngularFirestoreDocument(refInZone, this);\n    }\n    /**\n     * Returns a generated Firestore Document Id.\n     */\n    createId() {\n        return this.firestore.collection('_').doc().id;\n    }\n}\nAngularFirestore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestore, deps: [{ token: FIREBASE_OPTIONS }, { token: FIREBASE_APP_NAME, optional: true }, { token: ENABLE_PERSISTENCE, optional: true }, { token: SETTINGS, optional: true }, { token: PLATFORM_ID }, { token: i0.NgZone }, { token: i1.ɵAngularFireSchedulers }, { token: PERSISTENCE_SETTINGS, optional: true }, { token: USE_EMULATOR, optional: true }, { token: i2.AngularFireAuth, optional: true }, { token: USE_EMULATOR$1, optional: true }, { token: SETTINGS$1, optional: true }, { token: TENANT_ID, optional: true }, { token: LANGUAGE_CODE, optional: true }, { token: USE_DEVICE_LANGUAGE, optional: true }, { token: PERSISTENCE, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nAngularFirestore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestore, providedIn: 'any' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestore, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'any'\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FIREBASE_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FIREBASE_APP_NAME]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ENABLE_PERSISTENCE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [SETTINGS]\n                }] }, { type: Object, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }, { type: i0.NgZone }, { type: i1.ɵAngularFireSchedulers }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [PERSISTENCE_SETTINGS]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR]\n                }] }, { type: i2.AngularFireAuth, decorators: [{\n                    type: Optional\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_EMULATOR$1]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [SETTINGS$1]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [TENANT_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [LANGUAGE_CODE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [USE_DEVICE_LANGUAGE]\n                }] }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [PERSISTENCE]\n                }] }]; } });\n\nclass AngularFirestoreModule {\n    constructor() {\n        firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n    }\n    /**\n     * Attempt to enable persistent storage, if possible\n     */\n    static enablePersistence(persistenceSettings) {\n        return {\n            ngModule: AngularFirestoreModule,\n            providers: [\n                { provide: ENABLE_PERSISTENCE, useValue: true },\n                { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n            ]\n        };\n    }\n}\nAngularFirestoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nAngularFirestoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestoreModule });\nAngularFirestoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestoreModule, providers: [AngularFirestore] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.1.3\", ngImport: i0, type: AngularFirestoreModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    providers: [AngularFirestore]\n                }]\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };\n"]},"metadata":{},"sourceType":"module"}