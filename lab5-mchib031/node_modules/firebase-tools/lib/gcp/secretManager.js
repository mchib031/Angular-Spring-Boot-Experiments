"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.grantServiceAgentRole = exports.addVersion = exports.createSecret = exports.parseSecretResourceName = exports.secretExists = exports.getSecretLabels = exports.getSecret = exports.listSecrets = void 0;
const api = require("../api");
async function listSecrets(projectId) {
    const listRes = await api.request("GET", `/v1beta1/projects/${projectId}/secrets`, {
        auth: true,
        origin: api.secretManagerOrigin,
    });
    return listRes.body.secrets.map((s) => parseSecretResourceName(s.name));
}
exports.listSecrets = listSecrets;
async function getSecret(projectId, name) {
    const getRes = await api.request("GET", `/v1beta1/projects/${projectId}/secrets/${name}`, {
        auth: true,
        origin: api.secretManagerOrigin,
    });
    return parseSecretResourceName(getRes.body.name);
}
exports.getSecret = getSecret;
async function getSecretLabels(projectId, name) {
    const getRes = await api.request("GET", `/v1beta1/projects/${projectId}/secrets/${name}`, {
        auth: true,
        origin: api.secretManagerOrigin,
    });
    return getRes.body.labels;
}
exports.getSecretLabels = getSecretLabels;
async function secretExists(projectId, name) {
    try {
        await getSecret(projectId, name);
        return true;
    }
    catch (err) {
        if (err.status === 404) {
            return false;
        }
        throw err;
    }
}
exports.secretExists = secretExists;
function parseSecretResourceName(resourceName) {
    const nameTokens = resourceName.split("/");
    return {
        projectId: nameTokens[1],
        name: nameTokens[3],
    };
}
exports.parseSecretResourceName = parseSecretResourceName;
async function createSecret(projectId, name, labels) {
    const createRes = await api.request("POST", `/v1beta1/projects/${projectId}/secrets?secretId=${name}`, {
        auth: true,
        origin: api.secretManagerOrigin,
        data: {
            replication: {
                automatic: {},
            },
            labels,
        },
    });
    return parseSecretResourceName(createRes.body.name);
}
exports.createSecret = createSecret;
async function addVersion(secret, payloadData) {
    const res = await api.request("POST", `/v1beta1/projects/${secret.projectId}/secrets/${secret.name}:addVersion`, {
        auth: true,
        origin: api.secretManagerOrigin,
        data: {
            payload: {
                data: Buffer.from(payloadData).toString("base64"),
            },
        },
    });
    const nameTokens = res.body.name.split("/");
    return {
        secret: {
            projectId: nameTokens[1],
            name: nameTokens[3],
        },
        versionId: nameTokens[5],
    };
}
exports.addVersion = addVersion;
async function grantServiceAgentRole(secret, serviceAccountEmail, role) {
    const getPolicyRes = await api.request("GET", `/v1beta1/projects/${secret.projectId}/secrets/${secret.name}:getIamPolicy`, {
        auth: true,
        origin: api.secretManagerOrigin,
    });
    const bindings = getPolicyRes.body.bindings || [];
    if (bindings.find((b) => b.role == role &&
        b.members.find((m) => m == `serviceAccount:${serviceAccountEmail}`))) {
        return;
    }
    bindings.push({
        role: role,
        members: [`serviceAccount:${serviceAccountEmail}`],
    });
    await api.request("POST", `/v1beta1/projects/${secret.projectId}/secrets/${secret.name}:setIamPolicy`, {
        auth: true,
        origin: api.secretManagerOrigin,
        data: {
            policy: {
                bindings,
            },
            updateMask: {
                paths: "bindings",
            },
        },
    });
}
exports.grantServiceAgentRole = grantServiceAgentRole;
